<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>c-iterplus: itplus.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

<link href="doxygen.css" rel="stylesheet" type="text/css" />

</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">c-iterplus
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Type safe, Generic, Lazy abstractions for working with c-iterator</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('itplus_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">itplus.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All your iterplus needs in a single header file.  
<a href="#details">More...</a></p>

<p><a href="itplus_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ade6d0024e13054e359e088936f8fd8f9"><td class="memItemLeft" align="right" valign="top"><a id="ade6d0024e13054e359e088936f8fd8f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITPL_CONCAT_</b>(A,  B)&#160;&#160;&#160;A##B</td></tr>
<tr class="separator:ade6d0024e13054e359e088936f8fd8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956f49258ac8eea740d6cb9916b88ec0"><td class="memItemLeft" align="right" valign="top"><a id="a956f49258ac8eea740d6cb9916b88ec0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITPL_CONCAT</b>(A,  B)&#160;&#160;&#160;ITPL_CONCAT_(A, B)</td></tr>
<tr class="separator:a956f49258ac8eea740d6cb9916b88ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36f9f0d3603452a867a683078618034"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(funcs)</td></tr>
<tr class="memdesc:ab36f9f0d3603452a867a683078618034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a typeclass with the given functions.  <a href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">More...</a><br /></td></tr>
<tr class="separator:ab36f9f0d3603452a867a683078618034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af018200b2431a3ab6c296cc8940ecbe3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a>(Typeclass)</td></tr>
<tr class="memdesc:af018200b2431a3ab6c296cc8940ecbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a typeclass instance for the given typeclass.  <a href="itplus_8h.html#af018200b2431a3ab6c296cc8940ecbe3">More...</a><br /></td></tr>
<tr class="separator:af018200b2431a3ab6c296cc8940ecbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a0e4269e370939835ecc0cf6c7875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T)&#160;&#160;&#160;ITPL_CONCAT(Maybe_, T)</td></tr>
<tr class="memdesc:af47a0e4269e370939835ecc0cf6c7875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the Maybe defined with a certain type.  <a href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">More...</a><br /></td></tr>
<tr class="separator:af47a0e4269e370939835ecc0cf6c7875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daf26d181160b7fb96d640ed20bb466"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(T)</td></tr>
<tr class="memdesc:a0daf26d181160b7fb96d640ed20bb466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a Maybe&lt;T&gt; type.  <a href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">More...</a><br /></td></tr>
<tr class="separator:a0daf26d181160b7fb96d640ed20bb466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0832f95d5a7ff6845381aa8795fd2a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(v,  T)&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T)){.tag = <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2">MaybeTag_Just</a>, .val = (v)})</td></tr>
<tr class="memdesc:ae0832f95d5a7ff6845381aa8795fd2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a <code>Just</code> value into a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>.  <a href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">More...</a><br /></td></tr>
<tr class="separator:ae0832f95d5a7ff6845381aa8795fd2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cd69857cc806545d68c79464270a97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T)&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T)){0})</td></tr>
<tr class="memdesc:a65cd69857cc806545d68c79464270a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a <code>Nothing</code> value into a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>.  <a href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">More...</a><br /></td></tr>
<tr class="separator:a65cd69857cc806545d68c79464270a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b03ece9f7b00fcbbe8e0dde45277c47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(x)&#160;&#160;&#160;((x).tag == <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230aae774bc4d692f226f6a9d88b7e1ce26f">MaybeTag_Nothing</a>)</td></tr>
<tr class="memdesc:a1b03ece9f7b00fcbbe8e0dde45277c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given Maybe type is tagged with <code>Nothing</code>.  <a href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">More...</a><br /></td></tr>
<tr class="separator:a1b03ece9f7b00fcbbe8e0dde45277c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae2e9c065fbca1cd3a603ad0a71d8f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(x)&#160;&#160;&#160;((x).tag == <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2">MaybeTag_Just</a>)</td></tr>
<tr class="memdesc:a8ae2e9c065fbca1cd3a603ad0a71d8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given Maybe type is tagged with <code>Just</code>.  <a href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">More...</a><br /></td></tr>
<tr class="separator:a8ae2e9c065fbca1cd3a603ad0a71d8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26feaafcb3e37674333f6673ec2bdb7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a26feaafcb3e37674333f6673ec2bdb7d">from_just</a>(x,  T)&#160;&#160;&#160;ITPL_CONCAT(T, _from_just(x))</td></tr>
<tr class="memdesc:a26feaafcb3e37674333f6673ec2bdb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the <code>Just</code> value from given <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>.  <a href="itplus_8h.html#a26feaafcb3e37674333f6673ec2bdb7d">More...</a><br /></td></tr>
<tr class="separator:a26feaafcb3e37674333f6673ec2bdb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16682b211c71e2ad917edc9bdd298154"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(x)&#160;&#160;&#160;(x).val</td></tr>
<tr class="memdesc:a16682b211c71e2ad917edc9bdd298154"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Unsafe" version of <a class="el" href="itplus_8h.html#a26feaafcb3e37674333f6673ec2bdb7d" title="Extract the Just value from given Maybe(T).">from_just(x, T)</a>.  <a href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">More...</a><br /></td></tr>
<tr class="separator:a16682b211c71e2ad917edc9bdd298154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cf196d6558cc31ef4f88e5cf47bdf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a78cf196d6558cc31ef4f88e5cf47bdf9">fmap_maybe</a>(x,  fn,  R)&#160;&#160;&#160;<a class="el" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(x) ? <a class="el" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(R) : <a class="el" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(fn(<a class="el" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(x)), R)</td></tr>
<tr class="memdesc:a78cf196d6558cc31ef4f88e5cf47bdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the function <code>fn</code> over <code>x</code> to construct a <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(R)</a></code>.  <a href="itplus_8h.html#a78cf196d6558cc31ef4f88e5cf47bdf9">More...</a><br /></td></tr>
<tr class="separator:a78cf196d6558cc31ef4f88e5cf47bdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a22862dc6db425dd4389987c0dbaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a>(T)&#160;&#160;&#160;ITPL_CONCAT(Iterator_, T)</td></tr>
<tr class="memdesc:a6c3a22862dc6db425dd4389987c0dbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the Iterator (typeclass) with given element type.  <a href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">More...</a><br /></td></tr>
<tr class="separator:a6c3a22862dc6db425dd4389987c0dbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1cf949c0e970b2105124f691f5c2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T)&#160;&#160;&#160;ITPL_CONCAT(Iterable_, T)</td></tr>
<tr class="memdesc:a78f1cf949c0e970b2105124f691f5c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the Iterable (typeclass instance) with given element type.  <a href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">More...</a><br /></td></tr>
<tr class="separator:a78f1cf949c0e970b2105124f691f5c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938f3e7187cb386e2bf4049753e2ff84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(T)</td></tr>
<tr class="memdesc:a938f3e7187cb386e2bf4049753e2ff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an Iterator typeclass and its Iterable instance for given element type.  <a href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">More...</a><br /></td></tr>
<tr class="separator:a938f3e7187cb386e2bf4049753e2ff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e620430099d2eb6192db193e88cff0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a01e620430099d2eb6192db193e88cff0">impl_iterator</a>(IterType,  ElmntType,  Name,  next_f)</td></tr>
<tr class="memdesc:a01e620430099d2eb6192db193e88cff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn given <code>IterType</code> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a>.  <a href="itplus_8h.html#a01e620430099d2eb6192db193e88cff0">More...</a><br /></td></tr>
<tr class="separator:a01e620430099d2eb6192db193e88cff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4760cf36bdc0a23827c20b1963186503"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T,  U)&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(Pair_, T), ITPL_CONCAT(_, U))</td></tr>
<tr class="memdesc:a4760cf36bdc0a23827c20b1963186503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the Pair defined with certain types.  <a href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">More...</a><br /></td></tr>
<tr class="separator:a4760cf36bdc0a23827c20b1963186503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47436e1eab38cb119ab53fce7ab67e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a>(T,  U)</td></tr>
<tr class="memdesc:af47436e1eab38cb119ab53fce7ab67e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a Pair&lt;T, U&gt; type.  <a href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">More...</a><br /></td></tr>
<tr class="separator:af47436e1eab38cb119ab53fce7ab67e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6399a724fdf5a1af19dea3e3c25ec21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">PairOf</a>(x,  y,  T,  U)&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U)){.a = (x), .b = (y)})</td></tr>
<tr class="memdesc:ac6399a724fdf5a1af19dea3e3c25ec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap 2 values into a <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a>.  <a href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">More...</a><br /></td></tr>
<tr class="separator:ac6399a724fdf5a1af19dea3e3c25ec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728ef7d0189fc6bf3879edb5fd0c136"><td class="memItemLeft" align="right" valign="top"><a id="ae728ef7d0189fc6bf3879edb5fd0c136"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ae728ef7d0189fc6bf3879edb5fd0c136">fst</a>(pair)&#160;&#160;&#160;(pair).a</td></tr>
<tr class="memdesc:ae728ef7d0189fc6bf3879edb5fd0c136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first value from given pair. <br /></td></tr>
<tr class="separator:ae728ef7d0189fc6bf3879edb5fd0c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828c0ffd47ae7513e1674db7ab294fc"><td class="memItemLeft" align="right" valign="top"><a id="a8828c0ffd47ae7513e1674db7ab294fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a8828c0ffd47ae7513e1674db7ab294fc">snd</a>(pair)&#160;&#160;&#160;(pair).b</td></tr>
<tr class="memdesc:a8828c0ffd47ae7513e1674db7ab294fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the second value from given pair. <br /></td></tr>
<tr class="separator:a8828c0ffd47ae7513e1674db7ab294fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945bf384552243e0ebd9fb98d4a11db6"><td class="memItemLeft" align="right" valign="top"><a id="a945bf384552243e0ebd9fb98d4a11db6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNIQVAR</b>(x)&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(x, _4x2_), __LINE__) /* &quot;Unique&quot; variable name */</td></tr>
<tr class="separator:a945bf384552243e0ebd9fb98d4a11db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0308d3d97154ab14aa4025fcbacd0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a80a0308d3d97154ab14aa4025fcbacd0">foreach</a>(T,  x,  it)</td></tr>
<tr class="memdesc:a80a0308d3d97154ab14aa4025fcbacd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through given iterable and store each element in <code>x</code>  <a href="itplus_8h.html#a80a0308d3d97154ab14aa4025fcbacd0">More...</a><br /></td></tr>
<tr class="separator:a80a0308d3d97154ab14aa4025fcbacd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f7569f7996a4aa3ae1aa3d0327ec75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterChain_, T)</td></tr>
<tr class="memdesc:a57f7569f7996a4aa3ae1aa3d0327ec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterChain struct with given element type.  <a href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">More...</a><br /></td></tr>
<tr class="separator:a57f7569f7996a4aa3ae1aa3d0327ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1382e263ec1cd56a19bf91d8292a2824"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">DefineIterChain</a>(T)</td></tr>
<tr class="memdesc:a1382e263ec1cd56a19bf91d8292a2824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterChain struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">More...</a><br /></td></tr>
<tr class="separator:a1382e263ec1cd56a19bf91d8292a2824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2997b1c1acb16a74ad058b5dd4efb13c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a2997b1c1acb16a74ad058b5dd4efb13c">define_iterchain_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a2997b1c1acb16a74ad058b5dd4efb13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75" title="Convenience macro to get the type of the IterChain struct with given element type.">IterChain(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#a2997b1c1acb16a74ad058b5dd4efb13c">More...</a><br /></td></tr>
<tr class="separator:a2997b1c1acb16a74ad058b5dd4efb13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdde206edc4c79e8bbe20621fc1302ac"><td class="memItemLeft" align="right" valign="top"><a id="acdde206edc4c79e8bbe20621fc1302ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITPLUS_COLLECT_BUFSZ</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:acdde206edc4c79e8bbe20621fc1302ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93dbce7d63cb1c11818e4bf867a22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a85f93dbce7d63cb1c11818e4bf867a22">define_itercollect_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a85f93dbce7d63cb1c11818e4bf867a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the <code>collect</code> function for an iterable.  <a href="itplus_8h.html#a85f93dbce7d63cb1c11818e4bf867a22">More...</a><br /></td></tr>
<tr class="separator:a85f93dbce7d63cb1c11818e4bf867a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e55b9588c1634ec791b400eb4a9011e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterDrop_, T)</td></tr>
<tr class="memdesc:a6e55b9588c1634ec791b400eb4a9011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterDrop struct with given element type.  <a href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">More...</a><br /></td></tr>
<tr class="separator:a6e55b9588c1634ec791b400eb4a9011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71664a9dd47e10449841bfc1d6248503"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">DefineIterDrop</a>(T)</td></tr>
<tr class="memdesc:a71664a9dd47e10449841bfc1d6248503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterDrop struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">More...</a><br /></td></tr>
<tr class="separator:a71664a9dd47e10449841bfc1d6248503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8516570a9996f2d26ab4b959687ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad">define_iterdrop_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a82e8516570a9996f2d26ab4b959687ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e" title="Convenience macro to get the type of the IterDrop struct with given element type.">IterDrop(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad">More...</a><br /></td></tr>
<tr class="separator:a82e8516570a9996f2d26ab4b959687ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f6455eceac6d293e6e54414c3356e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterDropWhile_, T)</td></tr>
<tr class="memdesc:a883f6455eceac6d293e6e54414c3356e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterDropWhile struct with given element type.  <a href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">More...</a><br /></td></tr>
<tr class="separator:a883f6455eceac6d293e6e54414c3356e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6129389904af6d8e22a76da42bd5961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">DefineIterDropWhile</a>(T)</td></tr>
<tr class="memdesc:ad6129389904af6d8e22a76da42bd5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterDropWhile struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">More...</a><br /></td></tr>
<tr class="separator:ad6129389904af6d8e22a76da42bd5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee7dc73bbaa1d2abde64dab352a6c24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24">define_iterdropwhile_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a8ee7dc73bbaa1d2abde64dab352a6c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e" title="Convenience macro to get the type of the IterDropWhile struct with given element type.">IterDropWhile(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24">More...</a><br /></td></tr>
<tr class="separator:a8ee7dc73bbaa1d2abde64dab352a6c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3969ffb53f197e7b65f90dce652cb5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterEnumr_, T)</td></tr>
<tr class="memdesc:ae3969ffb53f197e7b65f90dce652cb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterEnumr struct with given element types.  <a href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">More...</a><br /></td></tr>
<tr class="separator:ae3969ffb53f197e7b65f90dce652cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1c0c9b689bff859e100034f192fc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">DefineIterEnumr</a>(T)</td></tr>
<tr class="memdesc:a01a1c0c9b689bff859e100034f192fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterEnumr struct that works with on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">More...</a><br /></td></tr>
<tr class="separator:a01a1c0c9b689bff859e100034f192fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c033b2db8a15dda35aebfb417950443"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a4c033b2db8a15dda35aebfb417950443">define_iterenumr_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a4c033b2db8a15dda35aebfb417950443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b" title="Convenience macro to get the type of the IterEnumr struct with given element types.">IterEnumr(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> where <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(size_t, T)</a></code>.  <a href="itplus_8h.html#a4c033b2db8a15dda35aebfb417950443">More...</a><br /></td></tr>
<tr class="separator:a4c033b2db8a15dda35aebfb417950443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69fe586c6d8864d840c0658db0d363"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterFilt_, T)</td></tr>
<tr class="memdesc:a6a69fe586c6d8864d840c0658db0d363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterFilt struct with given element type.  <a href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">More...</a><br /></td></tr>
<tr class="separator:a6a69fe586c6d8864d840c0658db0d363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044891877ea79ca3eb40ca33b511daaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">DefineIterFilt</a>(T)</td></tr>
<tr class="memdesc:a044891877ea79ca3eb40ca33b511daaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterFilt struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">More...</a><br /></td></tr>
<tr class="separator:a044891877ea79ca3eb40ca33b511daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac99e224f5b437d2d8cff83053cec2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#aaac99e224f5b437d2d8cff83053cec2c">define_iterfilt_func</a>(T,  Name)</td></tr>
<tr class="memdesc:aaac99e224f5b437d2d8cff83053cec2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363" title="Convenience macro to get the type of the IterFilt struct with given element type.">IterFilt(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#aaac99e224f5b437d2d8cff83053cec2c">More...</a><br /></td></tr>
<tr class="separator:aaac99e224f5b437d2d8cff83053cec2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ce8c4f7f92df65e6fdfde9e1ac575"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType,  FnRetType)&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterFiltMap_, ElmntType), ITPL_CONCAT(_, FnRetType))</td></tr>
<tr class="memdesc:a341ce8c4f7f92df65e6fdfde9e1ac575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterFiltMap struct with given element type and function raw return type.  <a href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">More...</a><br /></td></tr>
<tr class="separator:a341ce8c4f7f92df65e6fdfde9e1ac575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00013069bf4e36640355ded3b293d72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">DefineIterFiltMap</a>(ElmntType,  FnRetType)</td></tr>
<tr class="memdesc:aa00013069bf4e36640355ded3b293d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterFiltMap struct that maps a function of type <code>FnRetType (*)(ElmntType)</code> over an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a></code>.  <a href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">More...</a><br /></td></tr>
<tr class="separator:aa00013069bf4e36640355ded3b293d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f3e9d5e37fe8fcf894f1795ebd1fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">define_iterfiltmap_func</a>(ElmntType,  FnRetType,  Name)</td></tr>
<tr class="memdesc:a1c7f3e9d5e37fe8fcf894f1795ebd1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575" title="Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...">IterFiltMap(ElmntType, FnRetType)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a>.  <a href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">More...</a><br /></td></tr>
<tr class="separator:a1c7f3e9d5e37fe8fcf894f1795ebd1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8803f1b77884ca096246f7d95392e37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#af8803f1b77884ca096246f7d95392e37">define_iterfold_func</a>(T,  Acc,  Name)</td></tr>
<tr class="memdesc:af8803f1b77884ca096246f7d95392e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the <code>fold</code> function for an iterable and an accumulator type.  <a href="itplus_8h.html#af8803f1b77884ca096246f7d95392e37">More...</a><br /></td></tr>
<tr class="separator:af8803f1b77884ca096246f7d95392e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8fd79978d16823dc7cd3ef43fce28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType,  FnRetType)&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterMap_, ElmntType), ITPL_CONCAT(_, FnRetType))</td></tr>
<tr class="memdesc:a2ed8fd79978d16823dc7cd3ef43fce28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterMap struct with given element type and function return type.  <a href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">More...</a><br /></td></tr>
<tr class="separator:a2ed8fd79978d16823dc7cd3ef43fce28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8959a5cb249799f82f0c769fd43586e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">DefineIterMap</a>(ElmntType,  FnRetType)</td></tr>
<tr class="memdesc:af8959a5cb249799f82f0c769fd43586e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterMap struct that maps a function of type <code>FnRetType (*)(ElmntType)</code> over an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a></code>.  <a href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">More...</a><br /></td></tr>
<tr class="separator:af8959a5cb249799f82f0c769fd43586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc643234203e036aa3e0dede29beb73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73">define_itermap_func</a>(ElmntType,  FnRetType,  Name)</td></tr>
<tr class="memdesc:a4dc643234203e036aa3e0dede29beb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28" title="Convenience macro to get the type of the IterMap struct with given element type and function return t...">IterMap(ElmntType, FnRetType)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a>.  <a href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73">More...</a><br /></td></tr>
<tr class="separator:a4dc643234203e036aa3e0dede29beb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b36795100b8dd110f7f29c0c67e4b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3">define_iterreduce_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a00b36795100b8dd110f7f29c0c67e4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the <code>reduce</code> function for an iterable.  <a href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3">More...</a><br /></td></tr>
<tr class="separator:a00b36795100b8dd110f7f29c0c67e4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62bc1c52430417ab0ce36039c0c57a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterTake, T)</td></tr>
<tr class="memdesc:ad62bc1c52430417ab0ce36039c0c57a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterTake struct with given element type.  <a href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">More...</a><br /></td></tr>
<tr class="separator:ad62bc1c52430417ab0ce36039c0c57a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a907117c644761f094973916334a18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a38a907117c644761f094973916334a18">DefineIterTake</a>(T)</td></tr>
<tr class="memdesc:a38a907117c644761f094973916334a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterTake struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a38a907117c644761f094973916334a18">More...</a><br /></td></tr>
<tr class="separator:a38a907117c644761f094973916334a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287ad5fb9bef31ac9370b3a231a82603"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603">define_itertake_func</a>(T,  Name)</td></tr>
<tr class="memdesc:a287ad5fb9bef31ac9370b3a231a82603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6" title="Convenience macro to get the type of the IterTake struct with given element type.">IterTake(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603">More...</a><br /></td></tr>
<tr class="separator:a287ad5fb9bef31ac9370b3a231a82603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0603baeec63df613f04d5f13f7975260"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T)&#160;&#160;&#160;ITPL_CONCAT(IterTakeWhile_, T)</td></tr>
<tr class="memdesc:a0603baeec63df613f04d5f13f7975260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterTakeWhile struct with given element type.  <a href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">More...</a><br /></td></tr>
<tr class="separator:a0603baeec63df613f04d5f13f7975260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789b4cc6f8b2fc52ed79788fbf45d4e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">DefineIterTakeWhile</a>(T)</td></tr>
<tr class="memdesc:a789b4cc6f8b2fc52ed79788fbf45d4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterTakeWhile struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s.  <a href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">More...</a><br /></td></tr>
<tr class="separator:a789b4cc6f8b2fc52ed79788fbf45d4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452ed305d5190978aa0d4327e33c408"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ab452ed305d5190978aa0d4327e33c408">define_itertakewhile_func</a>(T,  Name)</td></tr>
<tr class="memdesc:ab452ed305d5190978aa0d4327e33c408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260" title="Convenience macro to get the type of the IterTakeWhile struct with given element type.">IterTakeWhile(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>.  <a href="itplus_8h.html#ab452ed305d5190978aa0d4327e33c408">More...</a><br /></td></tr>
<tr class="separator:ab452ed305d5190978aa0d4327e33c408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4cf3e9b41350a8dbe6cb5a24d4d0d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T,  U)&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterZip_, T), ITPL_CONCAT(_, U))</td></tr>
<tr class="memdesc:aed4cf3e9b41350a8dbe6cb5a24d4d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to get the type of the IterZip struct with given element types.  <a href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">More...</a><br /></td></tr>
<tr class="separator:aed4cf3e9b41350a8dbe6cb5a24d4d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ecdbe44b62bf0fee28e221e58a97f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">DefineIterZip</a>(T,  U)</td></tr>
<tr class="memdesc:ab9ecdbe44b62bf0fee28e221e58a97f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an IterZip struct that works with an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code> and an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(U)</a></code>.  <a href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">More...</a><br /></td></tr>
<tr class="separator:ab9ecdbe44b62bf0fee28e221e58a97f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39546aa28cec10faef57954e59bd0950"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950">define_iterzip_func</a>(T,  U,  Name)</td></tr>
<tr class="memdesc:a39546aa28cec10faef57954e59bd0950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to turn an <a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2" title="Convenience macro to get the type of the IterZip struct with given element types.">IterZip(T, U)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> where <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a></code>.  <a href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950">More...</a><br /></td></tr>
<tr class="separator:a39546aa28cec10faef57954e59bd0950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c50e13ec0251aa058caede675387b12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a5c50e13ec0251aa058caede675387b12">Iterplus</a>(T)</td></tr>
<tr class="memdesc:a5c50e13ec0251aa058caede675387b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define all structs needed for implementing <code>Iterator</code>, as well as iterplus utilities, for given <code>T</code>.  <a href="itplus_8h.html#a5c50e13ec0251aa058caede675387b12">More...</a><br /></td></tr>
<tr class="separator:a5c50e13ec0251aa058caede675387b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42bf07174d44f9e400ce68d5d7b9f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#a2d42bf07174d44f9e400ce68d5d7b9f6">DeclIterplus</a>(T,  takefn,  dropfn,  mapfn,  filterfn,  reducefn,  foldfn,  filter_mapfn,  chainfn,  takewhilefn,  dropwhilefn,  enumeratefn,  zipfn,  collectfn)</td></tr>
<tr class="memdesc:a2d42bf07174d44f9e400ce68d5d7b9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare iterplus utility functions defined using <code>DefnIterplus</code>.  <a href="itplus_8h.html#a2d42bf07174d44f9e400ce68d5d7b9f6">More...</a><br /></td></tr>
<tr class="separator:a2d42bf07174d44f9e400ce68d5d7b9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ec30413b0bc92c99b5c095578e368d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#ae7ec30413b0bc92c99b5c095578e368d">DefnIterplus</a>(T,  takefn,  dropfn,  mapfn,  filterfn,  reducefn,  foldfn,  filter_mapfn,  chainfn,  takewhilefn,  dropwhilefn,  enumeratefn,  zipfn,  collectfn)</td></tr>
<tr class="memdesc:ae7ec30413b0bc92c99b5c095578e368d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define all iterplus utilities for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> for given <code>T</code>, with given names.  <a href="itplus_8h.html#ae7ec30413b0bc92c99b5c095578e368d">More...</a><br /></td></tr>
<tr class="separator:ae7ec30413b0bc92c99b5c095578e368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aef352f4183ce21f9ac15edd86a75b230"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230">MaybeTag</a> { <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230aae774bc4d692f226f6a9d88b7e1ce26f">MaybeTag_Nothing</a> = 0
, <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2">MaybeTag_Just</a>
 }</td></tr>
<tr class="separator:aef352f4183ce21f9ac15edd86a75b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">All your iterplus needs in a single header file. </p>
<p class="">Repo: <a href="https://github.com/TotallyNotChase/c-iterplus">https://github.com/TotallyNotChase/c-iterplus</a></p>
<dl class="section author"><dt>Author</dt><dd>TotallyNotChase </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>MIT License</dd></dl>
<p>Copyright (c) 2021 TotallyNotChase</p>
<p class="">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p class="">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p class="">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2d42bf07174d44f9e400ce68d5d7b9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d42bf07174d44f9e400ce68d5d7b9f6">&#9670;&nbsp;</a></span>DeclIterplus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DeclIterplus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">takefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dropfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mapfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">filterfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reducefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">foldfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">filter_mapfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chainfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">takewhilefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dropwhilefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">enumeratefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">zipfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">collectfn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) takefn(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T) * x);                                                                               \</div>
<div class="line">    Iterable(T) dropfn(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T) * x);                                                                               \</div>
<div class="line">    Iterable(T) mapfn(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(T, T) * x);                                                                              \</div>
<div class="line">    Iterable(T) filterfn(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T) * x);                                                                             \</div>
<div class="line">    Iterable(T) filter_mapfn(<a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(T, T) * x);                                                                   \</div>
<div class="line">    Iterable(T) chainfn(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T) * x);                                                                             \</div>
<div class="line">    Maybe(T) reducefn(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, T (*f)(T acc, T x));                                                             \</div>
<div class="line">    Iterable(T) takewhilefn(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T) * x);                                                                     \</div>
<div class="line">    Iterable(T) dropwhilefn(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T) * x);                                                                     \</div>
<div class="line">    T* collectfn(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, <span class="keywordtype">size_t</span>* len);                                                                         \</div>
<div class="line">    T foldfn(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, T init, T (*f)(T acc, T x));                                                              \</div>
<div class="line">    Iterable(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T)) enumeratefn(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T) * x);                                                           \</div>
<div class="line">    Iterable(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, T)) zipfn(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, T) * x)</div>
<div class="ttc" id="aitplus_8h_html_a0603baeec63df613f04d5f13f7975260"><div class="ttname"><a href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a></div><div class="ttdeci">#define IterTakeWhile(T)</div><div class="ttdoc">Convenience macro to get the type of the IterTakeWhile struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:1371</div></div>
<div class="ttc" id="aitplus_8h_html_a2ed8fd79978d16823dc7cd3ef43fce28"><div class="ttname"><a href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a></div><div class="ttdeci">#define IterMap(ElmntType, FnRetType)</div><div class="ttdoc">Convenience macro to get the type of the IterMap struct with given element type and function return t...</div><div class="ttdef"><b>Definition:</b> itplus.h:1139</div></div>
<div class="ttc" id="aitplus_8h_html_a341ce8c4f7f92df65e6fdfde9e1ac575"><div class="ttname"><a href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a></div><div class="ttdeci">#define IterFiltMap(ElmntType, FnRetType)</div><div class="ttdoc">Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...</div><div class="ttdef"><b>Definition:</b> itplus.h:979</div></div>
<div class="ttc" id="aitplus_8h_html_a4760cf36bdc0a23827c20b1963186503"><div class="ttname"><a href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a></div><div class="ttdeci">#define Pair(T, U)</div><div class="ttdoc">Convenience macro to get the type of the Pair defined with certain types.</div><div class="ttdef"><b>Definition:</b> itplus.h:371</div></div>
<div class="ttc" id="aitplus_8h_html_a57f7569f7996a4aa3ae1aa3d0327ec75"><div class="ttname"><a href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a></div><div class="ttdeci">#define IterChain(T)</div><div class="ttdoc">Convenience macro to get the type of the IterChain struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:466</div></div>
<div class="ttc" id="aitplus_8h_html_a6a69fe586c6d8864d840c0658db0d363"><div class="ttname"><a href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a></div><div class="ttdeci">#define IterFilt(T)</div><div class="ttdoc">Convenience macro to get the type of the IterFilt struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:884</div></div>
<div class="ttc" id="aitplus_8h_html_a6e55b9588c1634ec791b400eb4a9011e"><div class="ttname"><a href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a></div><div class="ttdeci">#define IterDrop(T)</div><div class="ttdoc">Convenience macro to get the type of the IterDrop struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:612</div></div>
<div class="ttc" id="aitplus_8h_html_a78f1cf949c0e970b2105124f691f5c2a"><div class="ttname"><a href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a></div><div class="ttdeci">#define Iterable(T)</div><div class="ttdoc">Convenience macro to get the type of the Iterable (typeclass instance) with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:270</div></div>
<div class="ttc" id="aitplus_8h_html_a883f6455eceac6d293e6e54414c3356e"><div class="ttname"><a href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a></div><div class="ttdeci">#define IterDropWhile(T)</div><div class="ttdoc">Convenience macro to get the type of the IterDropWhile struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:701</div></div>
<div class="ttc" id="aitplus_8h_html_ad62bc1c52430417ab0ce36039c0c57a6"><div class="ttname"><a href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a></div><div class="ttdeci">#define IterTake(T)</div><div class="ttdoc">Convenience macro to get the type of the IterTake struct with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:1284</div></div>
<div class="ttc" id="aitplus_8h_html_ae3969ffb53f197e7b65f90dce652cb5b"><div class="ttname"><a href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a></div><div class="ttdeci">#define IterEnumr(T)</div><div class="ttdoc">Convenience macro to get the type of the IterEnumr struct with given element types.</div><div class="ttdef"><b>Definition:</b> itplus.h:798</div></div>
<div class="ttc" id="aitplus_8h_html_aed4cf3e9b41350a8dbe6cb5a24d4d0d2"><div class="ttname"><a href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a></div><div class="ttdeci">#define IterZip(T, U)</div><div class="ttdoc">Convenience macro to get the type of the IterZip struct with given element types.</div><div class="ttdef"><b>Definition:</b> itplus.h:1469</div></div>
</div><!-- fragment -->
<p>Declare iterplus utility functions defined using <code>DefnIterplus</code>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a2d42bf07174d44f9e400ce68d5d7b9f6">DeclIterplus</a>(<span class="keywordtype">int</span>, inttake_itr, intdrop_itr, intintmap_itr, intfilt_itr, intreduce, intfold, intfiltmap_itr,</div>
<div class="line">intchain_itr, inttkwhl_itr, intdrpwhl_itr, intenumr_itr, intzip_itr, intclct);</div>
<div class="line"><span class="comment">// Expands to the following:-</span></div>
<div class="line"><span class="comment">// Iterable(int) inttake_itr(IterTake(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intdrop_itr(IterDrop(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intintmap_itr(IterMap(int, int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intfilt_itr(IterFilt(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intfiltmap_itr(IterFiltMap(int, int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intchain_itr(IterChain(int) * x);</span></div>
<div class="line"><span class="comment">// Maybe(int) intreduce(Iterable(int) it, int (*f)(int acc, int x));</span></div>
<div class="line"><span class="comment">// Iterable(int) inttkwhl_itr(IterTakeWhile(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intdrpwhl_itr(IterDropWhile(int) * x);</span></div>
<div class="line"><span class="comment">// int* intclct(Iterable(int) it, size_t* len);</span></div>
<div class="line"><span class="comment">// int intfold(Iterable(int) it, int init, int (*f)(int acc, int x));</span></div>
<div class="line"><span class="comment">// Iterable(Pair(size_t, int)) intenumr_itr(IterEnumr(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(Pair(int, int)) intzip_itr(IterZip(int, int) * x);</span></div>
<div class="ttc" id="aitplus_8h_html_a2d42bf07174d44f9e400ce68d5d7b9f6"><div class="ttname"><a href="itplus_8h.html#a2d42bf07174d44f9e400ce68d5d7b9f6">DeclIterplus</a></div><div class="ttdeci">#define DeclIterplus(T, takefn, dropfn, mapfn, filterfn, reducefn, foldfn, filter_mapfn, chainfn, takewhilefn, dropwhilefn, enumeratefn, zipfn, collectfn)</div><div class="ttdoc">Declare iterplus utility functions defined using DefnIterplus.</div><div class="ttdef"><b>Definition:</b> itplus.h:1625</div></div>
</div><!-- fragment --><p class="">The parameters to this should be the same as the ones passed to <a class="el" href="itplus_8h.html#ae7ec30413b0bc92c99b5c095578e368d" title="Define all iterplus utilities for Iterable(T) for given T, with given names.">DefnIterplus</a>(T, takefn, dropfn, mapfn, filterfn, reducefn, foldfn, filter_mapfn, chainfn, takewhilefn, dropwhilefn, enumeratefn, zipfn, collectfn) </p>

</div>
</div>
<a id="a2997b1c1acb16a74ad058b5dd4efb13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2997b1c1acb16a74ad058b5dd4efb13c">&#9670;&nbsp;</a></span>define_iterchain_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterchain_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T), _nxt)(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T) * <span class="keyword">self</span>)                                               \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) srcit = <span class="keyword">self</span>-&gt;curr;                                                                                \</div>
<div class="line">        Maybe(T) res      = srcit.tc-&gt;next(srcit.self);                                                                \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(res)) {                                                                                            \</div>
<div class="line">            return res;                                                                                                \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        self-&gt;curr           = <span class="keyword">self</span>-&gt;nxt;                                                                              \</div>
<div class="line">        Iterable(T) re_srcit = <span class="keyword">self</span>-&gt;curr;                                                                             \</div>
<div class="line">        return re_srcit.tc-&gt;next(re_srcit.self);                                                                       \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T), _nxt))</div>
<div class="ttc" id="aitplus_8h_html_a8ae2e9c065fbca1cd3a603ad0a71d8f2"><div class="ttname"><a href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a></div><div class="ttdeci">#define is_just(x)</div><div class="ttdoc">Check if the given Maybe type is tagged with Just.</div><div class="ttdef"><b>Definition:</b> itplus.h:191</div></div>
<div class="ttc" id="aitplus_8h_html_af47a0e4269e370939835ecc0cf6c7875"><div class="ttname"><a href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a></div><div class="ttdeci">#define Maybe(T)</div><div class="ttdoc">Convenience macro to get the type of the Maybe defined with a certain type.</div><div class="ttdef"><b>Definition:</b> itplus.h:108</div></div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75" title="Convenience macro to get the type of the IterChain struct with given element type.">IterChain(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75" title="Convenience macro to get the type of the IterChain struct with given element type.">IterChain(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75" title="Convenience macro to get the type of the IterChain struct with given element type.">IterChain(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">DefineIterChain</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterChain(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrchn(IterChain(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a2997b1c1acb16a74ad058b5dd4efb13c">define_iterchain_func</a>(<span class="keywordtype">int</span>, wrap_intitrchn)</div>
<div class="ttc" id="aitplus_8h_html_a1382e263ec1cd56a19bf91d8292a2824"><div class="ttname"><a href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">DefineIterChain</a></div><div class="ttdeci">#define DefineIterChain(T)</div><div class="ttdoc">Define an IterChain struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:483</div></div>
<div class="ttc" id="aitplus_8h_html_a2997b1c1acb16a74ad058b5dd4efb13c"><div class="ttname"><a href="itplus_8h.html#a2997b1c1acb16a74ad058b5dd4efb13c">define_iterchain_func</a></div><div class="ttdeci">#define define_iterchain_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterChain(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:524</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Chain together fst_it and snd_it (both of type `Iterable(int)`)</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) it = wrap_intitrchn(&amp;(<a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(<span class="keywordtype">int</span>)){ .curr = fst_it, .nxt = snd_it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterChain</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75" title="Convenience macro to get the type of the IterChain struct with given element type.">IterChain(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a85f93dbce7d63cb1c11818e4bf867a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93dbce7d63cb1c11818e4bf867a22">&#9670;&nbsp;</a></span>define_itercollect_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_itercollect_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    T* Name(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, <span class="keywordtype">size_t</span>* len)                                                                               \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        size_t size = ITPLUS_COLLECT_BUFSZ;                                                                            \</div>
<div class="line">        *len        = 0;                                                                                               \</div>
<div class="line">        T* arr      = malloc(size * <span class="keyword">sizeof</span>(*arr));                                                                     \</div>
<div class="line">        if (arr == NULL) {                                                                                             \</div>
<div class="line">            return NULL;                                                                                               \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        foreach (T, x, it) {                                                                                           \</div>
<div class="line">            if (*len == size) {                                                                                        \</div>
<div class="line">                T* temp = realloc(arr, (size *= 2) * <span class="keyword">sizeof</span>(*arr));                                                    \</div>
<div class="line">                if (temp == NULL) {                                                                                    \</div>
<div class="line">                    free(arr);                                                                                         \</div>
<div class="line">                    return NULL;                                                                                       \</div>
<div class="line">                }                                                                                                      \</div>
<div class="line">                arr = temp;                                                                                            \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">            arr[(*len)++] = x;                                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return arr;                                                                                                    \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define the <code>collect</code> function for an iterable. </p>
<p class="">The defined function takes in an iterable of type <code>T</code>, and turns it into an array. Each element of said array is of type <code>T</code>.</p>
<p class="">This defined function will consume the given iterable.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><span class="comment">// Defines a function with the signature- `int* collect_int(Iterable(int) x, size_t* len)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a85f93dbce7d63cb1c11818e4bf867a22">define_itercollect_func</a>(<span class="keywordtype">int</span>, collect_int)</div>
<div class="ttc" id="aitplus_8h_html_a85f93dbce7d63cb1c11818e4bf867a22"><div class="ttname"><a href="itplus_8h.html#a85f93dbce7d63cb1c11818e4bf867a22">define_itercollect_func</a></div><div class="ttdeci">#define define_itercollect_func(T, Name)</div><div class="ttdoc">Define the collect function for an iterable.</div><div class="ttdef"><b>Definition:</b> itplus.h:573</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> arrlen = 0;</div>
<div class="line"><span class="comment">// Collect `it` (of type `Iterable(int)`) into an array</span></div>
<div class="line"><span class="keywordtype">int</span>* intarr = collect_int(it, &amp;arrlen);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code>, for which this is being implemented, yields. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned array must be freed. </dd>
<dd>
If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a82e8516570a9996f2d26ab4b959687ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e8516570a9996f2d26ab4b959687ad">&#9670;&nbsp;</a></span>define_iterdrop_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterdrop_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T), _nxt)(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T) * <span class="keyword">self</span>)                                                 \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) srcit = <span class="keyword">self</span>-&gt;src;                                                                                 \</div>
<div class="line">        foreach (T, x, srcit) {                                                                                        \</div>
<div class="line">            if (self-&gt;i &gt;= self-&gt;limit) {                                                                              \</div>
<div class="line">                return <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(x, T);                                                                                     \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">            ++(<span class="keyword">self</span>-&gt;i);                                                                                               \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                             \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T), _nxt))</div>
<div class="ttc" id="aitplus_8h_html_a65cd69857cc806545d68c79464270a97"><div class="ttname"><a href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a></div><div class="ttdeci">#define Nothing(T)</div><div class="ttdoc">Wrap a Nothing value into a Maybe(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:176</div></div>
<div class="ttc" id="aitplus_8h_html_ae0832f95d5a7ff6845381aa8795fd2a3"><div class="ttname"><a href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a></div><div class="ttdeci">#define Just(v, T)</div><div class="ttdoc">Wrap a Just value into a Maybe(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:159</div></div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e" title="Convenience macro to get the type of the IterDrop struct with given element type.">IterDrop(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e" title="Convenience macro to get the type of the IterDrop struct with given element type.">IterDrop(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e" title="Convenience macro to get the type of the IterDrop struct with given element type.">IterDrop(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">DefineIterDrop</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterDrop(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrdrp(IterDrop(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad">define_iterdrop_func</a>(<span class="keywordtype">int</span>, wrap_intitrdrp)</div>
<div class="ttc" id="aitplus_8h_html_a71664a9dd47e10449841bfc1d6248503"><div class="ttname"><a href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">DefineIterDrop</a></div><div class="ttdeci">#define DefineIterDrop(T)</div><div class="ttdoc">Define an IterDrop struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:629</div></div>
<div class="ttc" id="aitplus_8h_html_a82e8516570a9996f2d26ab4b959687ad"><div class="ttname"><a href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad">define_iterdrop_func</a></div><div class="ttdeci">#define define_iterdrop_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterDrop(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:671</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Drop (skip) the first 10 elements from `it` (of type `Iterable(int)`) and create a new iterable</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) after10 = wrap_intitrdrp(&amp;(<a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(<span class="keywordtype">int</span>)){ .limit = 10, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDrop</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e" title="Convenience macro to get the type of the IterDrop struct with given element type.">IterDrop(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a8ee7dc73bbaa1d2abde64dab352a6c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee7dc73bbaa1d2abde64dab352a6c24">&#9670;&nbsp;</a></span>define_iterdropwhile_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterdropwhile_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T), _nxt)(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T) * <span class="keyword">self</span>)                                       \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        if (self-&gt;done) {                                                                                              \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        Iterable(T) srcit = <span class="keyword">self</span>-&gt;src;                                                                                 \</div>
<div class="line">        foreach (T, x, srcit) {                                                                                        \</div>
<div class="line">            if (!self-&gt;pred(x)) {                                                                                      \</div>
<div class="line">                self-&gt;done = <span class="keyword">true</span>;                                                                                     \</div>
<div class="line">                return <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(x, T);                                                                                     \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                             \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T), _nxt))</div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e" title="Convenience macro to get the type of the IterDropWhile struct with given element type.">IterDropWhile(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e" title="Convenience macro to get the type of the IterDropWhile struct with given element type.">IterDropWhile(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e" title="Convenience macro to get the type of the IterDropWhile struct with given element type.">IterDropWhile(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">DefineIterDropWhile</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterDropWhile(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrdrpwhl(IterDropWhile(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24">define_iterdropwhile_func</a>(<span class="keywordtype">int</span>, wrap_intitrdrpwhl)</div>
<div class="ttc" id="aitplus_8h_html_a8ee7dc73bbaa1d2abde64dab352a6c24"><div class="ttname"><a href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24">define_iterdropwhile_func</a></div><div class="ttdeci">#define define_iterdropwhile_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterDropWhile(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:764</div></div>
<div class="ttc" id="aitplus_8h_html_ad6129389904af6d8e22a76da42bd5961"><div class="ttname"><a href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">DefineIterDropWhile</a></div><div class="ttdeci">#define DefineIterDropWhile(T)</div><div class="ttdoc">Define an IterDropWhile struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:718</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> is_even(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Drop (skip) elements from `it` (of type `Iterable(int)`), while they satisfy `is_even`, and create a new iterable</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) after_evens = wrap_intitrdrpwhl(&amp;(<a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(<span class="keywordtype">int</span>)){ .pred = is_even, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDropWhile</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e" title="Convenience macro to get the type of the IterDropWhile struct with given element type.">IterDropWhile(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a4c033b2db8a15dda35aebfb417950443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c033b2db8a15dda35aebfb417950443">&#9670;&nbsp;</a></span>define_iterenumr_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterenumr_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T)) ITPL_CONCAT(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T), _nxt)(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T) * <span class="keyword">self</span>)                                 \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) srcit = <span class="keyword">self</span>-&gt;src;                                                                                 \</div>
<div class="line">        Maybe(T) res      = srcit.tc-&gt;next(srcit.self);                                                                \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(res) ? <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(<a class="code" href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">PairOf</a>(self-&gt;i++, <a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(res), <span class="keywordtype">size_t</span>, T), <a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T))                     \</div>
<div class="line">                            : <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T));                                                                \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T)*, <a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T), Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T), _nxt))</div>
<div class="ttc" id="aitplus_8h_html_a16682b211c71e2ad917edc9bdd298154"><div class="ttname"><a href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a></div><div class="ttdeci">#define from_just_(x)</div><div class="ttdoc">&quot;Unsafe&quot; version of from_just(x, T).</div><div class="ttdef"><b>Definition:</b> itplus.h:219</div></div>
<div class="ttc" id="aitplus_8h_html_ac6399a724fdf5a1af19dea3e3c25ec21"><div class="ttname"><a href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">PairOf</a></div><div class="ttdeci">#define PairOf(x, y, T, U)</div><div class="ttdoc">Wrap 2 values into a Pair(T, U).</div><div class="ttdef"><b>Definition:</b> itplus.h:417</div></div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b" title="Convenience macro to get the type of the IterEnumr struct with given element types.">IterEnumr(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> where <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(size_t, T)</a></code>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b" title="Convenience macro to get the type of the IterEnumr struct with given element types.">IterEnumr(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b" title="Convenience macro to get the type of the IterEnumr struct with given element types.">IterEnumr(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(Pair(size_t, T))</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">DefineIterEnumr</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterEnumr(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(Pair(size_t, int)) wrap_intenumr(IterEnumr(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a4c033b2db8a15dda35aebfb417950443">define_iterenumr_func</a>(<span class="keywordtype">int</span>, wrap_intenumr)</div>
<div class="ttc" id="aitplus_8h_html_a01a1c0c9b689bff859e100034f192fc1"><div class="ttname"><a href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">DefineIterEnumr</a></div><div class="ttdeci">#define DefineIterEnumr(T)</div><div class="ttdoc">Define an IterEnumr struct that works with on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:816</div></div>
<div class="ttc" id="aitplus_8h_html_a4c033b2db8a15dda35aebfb417950443"><div class="ttname"><a href="itplus_8h.html#a4c033b2db8a15dda35aebfb417950443">define_iterenumr_func</a></div><div class="ttdeci">#define define_iterenumr_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterEnumr(T) into an Iterable(T) where T = Pair(size_t,...</div><div class="ttdef"><b>Definition:</b> itplus.h:858</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Enumerate `it` (of type `Iterable(int)`) to create a new iterable</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, <span class="keywordtype">int</span>)) enumerated = wrap_intenumr(&amp;(<a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(<span class="keywordtype">int</span>)){ .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the first <code>Iterable</code> wrapped in this <code>IterEnumr</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b" title="Convenience macro to get the type of the IterEnumr struct with given element types.">IterEnumr(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a>, with <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(size_t, T)</a></code>, for the given <code>T</code>. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="aaac99e224f5b437d2d8cff83053cec2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac99e224f5b437d2d8cff83053cec2c">&#9670;&nbsp;</a></span>define_iterfilt_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterfilt_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T), _nxt)(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T) * <span class="keyword">self</span>)                                                 \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) <span class="keyword">const</span> srcit = <span class="keyword">self</span>-&gt;src;                                                                           \</div>
<div class="line">        while (1) {                                                                                                    \</div>
<div class="line">            Maybe(T) res = srcit.tc-&gt;next(srcit.self);                                                                 \</div>
<div class="line">            if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(res) || self-&gt;pred(<a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(res))) {                                                      \</div>
<div class="line">                return res;                                                                                            \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T), _nxt))</div>
<div class="ttc" id="aitplus_8h_html_a1b03ece9f7b00fcbbe8e0dde45277c47"><div class="ttname"><a href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a></div><div class="ttdeci">#define is_nothing(x)</div><div class="ttdoc">Check if the given Maybe type is tagged with Nothing.</div><div class="ttdef"><b>Definition:</b> itplus.h:184</div></div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363" title="Convenience macro to get the type of the IterFilt struct with given element type.">IterFilt(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363" title="Convenience macro to get the type of the IterFilt struct with given element type.">IterFilt(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363" title="Convenience macro to get the type of the IterFilt struct with given element type.">IterFilt(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">DefineIterFilt</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterFilt(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrfilt(IterFilt(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#aaac99e224f5b437d2d8cff83053cec2c">define_iterfilt_func</a>(<span class="keywordtype">int</span>, wrap_intitrfilt)</div>
<div class="ttc" id="aitplus_8h_html_a044891877ea79ca3eb40ca33b511daaf"><div class="ttname"><a href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">DefineIterFilt</a></div><div class="ttdeci">#define DefineIterFilt(T)</div><div class="ttdoc">Define an IterFilt struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:901</div></div>
<div class="ttc" id="aitplus_8h_html_aaac99e224f5b437d2d8cff83053cec2c"><div class="ttname"><a href="itplus_8h.html#aaac99e224f5b437d2d8cff83053cec2c">define_iterfilt_func</a></div><div class="ttdeci">#define define_iterfilt_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterFilt(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:946</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> is_even(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Filter `it` (of type `Iterable(int)`) by `is_even`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) evens = wrap_intitrfilt(&amp;(<a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(<span class="keywordtype">int</span>)){ .pred = is_even, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterFilt</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363" title="Convenience macro to get the type of the IterFilt struct with given element type.">IterFilt(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a1c7f3e9d5e37fe8fcf894f1795ebd1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">&#9670;&nbsp;</a></span>define_iterfiltmap_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterfiltmap_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(FnRetType)                                                                                            \</div>
<div class="line">        ITPL_CONCAT(<a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType, FnRetType), _nxt)(<a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType, FnRetType) * <span class="keyword">self</span>)                 \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(ElmntType) <span class="keyword">const</span> srcit = <span class="keyword">self</span>-&gt;src;                                                                   \</div>
<div class="line">        while (1) {                                                                                                    \</div>
<div class="line">            Maybe(ElmntType) res = srcit.tc-&gt;next(srcit.self);                                                         \</div>
<div class="line">            if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(res)) {                                                                                     \</div>
<div class="line">                return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(FnRetType);                                                                             \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">            Maybe(FnRetType) mapped = <span class="keyword">self</span>-&gt;f(<a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(res));                                                        \</div>
<div class="line">            if (<a class="code" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(mapped)) {                                                                                     \</div>
<div class="line">                return mapped;                                                                                         \</div>
<div class="line">            }                                                                                                          \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(                                                                                                     \</div>
<div class="line">        <a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType, FnRetType)*, FnRetType, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType, FnRetType), _nxt))</div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575" title="Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...">IterFiltMap(ElmntType, FnRetType)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575" title="Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...">IterFiltMap(ElmntType, FnRetType)</a> struct, and use it to implement the Iterator typeclass, for given <code>ElmntType</code> and <code>FnRetType</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575" title="Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...">IterFiltMap(ElmntType, FnRetType)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">DefineIterFiltMap</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterFiltMap(int, int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrfiltmp(IterFiltMap(int, int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">define_iterfiltmap_func</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, wrap_intitrfiltmp)</div>
<div class="ttc" id="aitplus_8h_html_a1c7f3e9d5e37fe8fcf894f1795ebd1fe"><div class="ttname"><a href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">define_iterfiltmap_func</a></div><div class="ttdeci">#define define_iterfiltmap_func(ElmntType, FnRetType, Name)</div><div class="ttdoc">Define a function to turn an IterFiltMap(ElmntType, FnRetType) into an Iterable(FnRetType).</div><div class="ttdef"><b>Definition:</b> itplus.h:1050</div></div>
<div class="ttc" id="aitplus_8h_html_aa00013069bf4e36640355ded3b293d72"><div class="ttname"><a href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">DefineIterFiltMap</a></div><div class="ttdeci">#define DefineIterFiltMap(ElmntType, FnRetType)</div><div class="ttdoc">Define an IterFiltMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(E...</div><div class="ttdef"><b>Definition:</b> itplus.h:1001</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Filter evens and then increment the even numbers</span></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<span class="keywordtype">int</span>) is_even_incr(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0 ? <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(x + 1, <span class="keywordtype">int</span>) : <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(int); }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Filter Map `it` (of type `Iterable(int)`) by `is_even_incr`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) incr_evens = wrap_intitrfiltmp(&amp;(<a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)){ .f = is_even_incr, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterFiltMap</code> will yield. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The <b>raw</b> type of value the function contained within an <code>IterFiltMap</code> struct will return. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics.. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575" title="Convenience macro to get the type of the IterFiltMap struct with given element type and function raw ...">IterFiltMap(ElmntType, FnRetType)</a> for the given <code>ElmntType</code> and <code>FnRetType</code> <b>must</b> exist. </dd>
<dd>
A filter-map function returns a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>, where <code>T</code> is <code>FnRetType</code>, also referred to as the "raw" return type. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="af8803f1b77884ca096246f7d95392e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8803f1b77884ca096246f7d95392e37">&#9670;&nbsp;</a></span>define_iterfold_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterfold_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Acc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    Acc Name(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, Acc init, Acc (*f)(Acc acc, T x))                                                         \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Acc acc = init;                                                                                                \</div>
<div class="line">        foreach (T, x, it) {                                                                                           \</div>
<div class="line">            acc = f(acc, x);                                                                                           \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return acc;                                                                                                    \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define the <code>fold</code> function for an iterable and an accumulator type. </p>
<p class="">The defined fold function takes in an iterable of type <code>T</code>, a function of type <code>Acc (*const f)(Acc acc, T x)</code>, and a starting value of type <code>Acc</code>, and folds the iterable to a singular value of type <code>Acc</code>, by repeatedly applying <code>f</code> onto it.</p>
<p class="">This defined function will consume the given iterable.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>boxint { <span class="keywordtype">int</span> x; } BoxInt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The defined function has the signature:-</span></div>
<div class="line"><span class="comment">// `BoxInt int_boxint_fold(Iterable(int), BoxInt init, BoxInt (*f)(BoxInt acc, int x))`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#af8803f1b77884ca096246f7d95392e37">define_iterfold_func</a>(<span class="keywordtype">int</span>, boxint, int_boxint_fold)</div>
<div class="ttc" id="aitplus_8h_html_af8803f1b77884ca096246f7d95392e37"><div class="ttname"><a href="itplus_8h.html#af8803f1b77884ca096246f7d95392e37">define_iterfold_func</a></div><div class="ttdeci">#define define_iterfold_func(T, Acc, Name)</div><div class="ttdoc">Define the fold function for an iterable and an accumulator type.</div><div class="ttdef"><b>Definition:</b> itplus.h:1110</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Add 2 ints within 2 BoxInts</span></div>
<div class="line"><span class="keyword">static</span> BoxInt boxed_add(BoxInt a, BoxInt b) { <span class="keywordflow">return</span> (BoxInt){ .x = a.x + b.x }; }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Fold `it` with `boxed_add`</span></div>
<div class="line">BoxInt boxed_sum = int_boxint_fold(it, (BoxInt){0}, boxed_add);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code>, for which this is being implemented, yields. </td></tr>
    <tr><td class="paramname">Acc</td><td>The accumulator type the fold function being defined should work on. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> (or <code>Acc</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd>
<dd>
This should not be delimited with a semicolon. </dd></dl>

</div>
</div>
<a id="a4dc643234203e036aa3e0dede29beb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc643234203e036aa3e0dede29beb73">&#9670;&nbsp;</a></span>define_itermap_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_itermap_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(FnRetType) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType, FnRetType), _nxt)(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType, FnRetType) * <span class="keyword">self</span>)     \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(ElmntType) <span class="keyword">const</span> srcit = <span class="keyword">self</span>-&gt;src;                                                                   \</div>
<div class="line">        Maybe(ElmntType) res            = srcit.tc-&gt;next(srcit.self);                                                  \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#a78cf196d6558cc31ef4f88e5cf47bdf9">fmap_maybe</a>(res, self-&gt;f, FnRetType);                                                                    \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType, FnRetType)*, FnRetType, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType, FnRetType), _nxt))</div>
<div class="ttc" id="aitplus_8h_html_a78cf196d6558cc31ef4f88e5cf47bdf9"><div class="ttname"><a href="itplus_8h.html#a78cf196d6558cc31ef4f88e5cf47bdf9">fmap_maybe</a></div><div class="ttdeci">#define fmap_maybe(x, fn, R)</div><div class="ttdoc">Map the function fn over x to construct a Maybe(R).</div><div class="ttdef"><b>Definition:</b> itplus.h:235</div></div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28" title="Convenience macro to get the type of the IterMap struct with given element type and function return t...">IterMap(ElmntType, FnRetType)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28" title="Convenience macro to get the type of the IterMap struct with given element type and function return t...">IterMap(ElmntType, FnRetType)</a> struct, and use it to implement the Iterator typeclass, for given <code>ElmntType</code> and <code>FnRetType</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28" title="Convenience macro to get the type of the IterMap struct with given element type and function return t...">IterMap(ElmntType, FnRetType)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(FnRetType)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">DefineIterMap</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterMap(int, int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrmp(IterMap(int, int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73">define_itermap_func</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, wrap_intitrmp)</div>
<div class="ttc" id="aitplus_8h_html_a4dc643234203e036aa3e0dede29beb73"><div class="ttname"><a href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73">define_itermap_func</a></div><div class="ttdeci">#define define_itermap_func(ElmntType, FnRetType, Name)</div><div class="ttdoc">Define a function to turn an IterMap(ElmntType, FnRetType) into an Iterable(FnRetType).</div><div class="ttdef"><b>Definition:</b> itplus.h:1207</div></div>
<div class="ttc" id="aitplus_8h_html_af8959a5cb249799f82f0c769fd43586e"><div class="ttname"><a href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">DefineIterMap</a></div><div class="ttdeci">#define DefineIterMap(ElmntType, FnRetType)</div><div class="ttdoc">Define an IterMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(Elmnt...</div><div class="ttdef"><b>Definition:</b> itplus.h:1159</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Decrement an int</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> decr(<span class="keywordtype">int</span> a) { <span class="keywordflow">return</span> a - 1; }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Map `decr` over `it` (of type `Iterable(int)`)</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) decr_it = wrap_intitrmp(&amp;(<a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)){ .f = decr, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterMap</code> will yield. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The type of value the function contained within an <code>IterMap</code> struct will return. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics.. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28" title="Convenience macro to get the type of the IterMap struct with given element type and function return t...">IterMap(ElmntType, FnRetType)</a> for the given <code>ElmntType</code> and <code>FnRetType</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a00b36795100b8dd110f7f29c0c67e4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b36795100b8dd110f7f29c0c67e4b3">&#9670;&nbsp;</a></span>define_iterreduce_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterreduce_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) Name(<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T) it, T (*f)(T acc, T x))                                                                  \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Maybe(T) res = it.tc-&gt;next(it.self);                                                                           \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(res)) {                                                                                         \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        T acc = <a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(res);                                                                                       \</div>
<div class="line">        foreach (T, x, it) {                                                                                           \</div>
<div class="line">            acc = f(acc, x);                                                                                           \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(acc, T);                                                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define the <code>reduce</code> function for an iterable. </p>
<p class="">The defined reduce function takes in an iterable of type <code>T</code>, and a function of type <code>T (*const f)(T acc, T x)</code>, and reduces the iterable to a singular value of type <code>T</code>, by repeatedly applying <code>f</code> onto it.</p>
<p class="">If the given iterable was empty, <code>Nothing</code> is returned. Otherwise, a <code>Just</code> value is returned.</p>
<p class="">This defined function will consume the given iterable.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><span class="comment">// The defined function has the signature:-</span></div>
<div class="line"><span class="comment">// `Maybe(int) int_reduce(Iterable(int), int (*f)(int acc, int x))`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3">define_iterreduce_func</a>(<span class="keywordtype">int</span>, int_reduce)</div>
<div class="ttc" id="aitplus_8h_html_a00b36795100b8dd110f7f29c0c67e4b3"><div class="ttname"><a href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3">define_iterreduce_func</a></div><div class="ttdeci">#define define_iterreduce_func(T, Name)</div><div class="ttdoc">Define the reduce function for an iterable.</div><div class="ttdef"><b>Definition:</b> itplus.h:1254</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Add 2 ints</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Reduce `it` (of type `Iterable(int)`) with `add`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<span class="keywordtype">int</span>) maybe_sum = int_reduce(it, add);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code>, for which this is being implemented, yields. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd>
<dd>
This should not be delimited with a semicolon. </dd></dl>

</div>
</div>
<a id="a287ad5fb9bef31ac9370b3a231a82603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287ad5fb9bef31ac9370b3a231a82603">&#9670;&nbsp;</a></span>define_itertake_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_itertake_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T), _nxt)(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T) * <span class="keyword">self</span>)                                                 \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        if (self-&gt;i &lt; self-&gt;limit) {                                                                                   \</div>
<div class="line">            ++(<span class="keyword">self</span>-&gt;i);                                                                                               \</div>
<div class="line">            Iterable(T) srcit = <span class="keyword">self</span>-&gt;src;                                                                             \</div>
<div class="line">            return srcit.tc-&gt;next(srcit.self);                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                             \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T), _nxt))</div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6" title="Convenience macro to get the type of the IterTake struct with given element type.">IterTake(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6" title="Convenience macro to get the type of the IterTake struct with given element type.">IterTake(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6" title="Convenience macro to get the type of the IterTake struct with given element type.">IterTake(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a38a907117c644761f094973916334a18">DefineIterTake</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterTake(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrtk(IterTake(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603">define_itertake_func</a>(<span class="keywordtype">int</span>, wrap_intitrtk)</div>
<div class="ttc" id="aitplus_8h_html_a287ad5fb9bef31ac9370b3a231a82603"><div class="ttname"><a href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603">define_itertake_func</a></div><div class="ttdeci">#define define_itertake_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterTake(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:1343</div></div>
<div class="ttc" id="aitplus_8h_html_a38a907117c644761f094973916334a18"><div class="ttname"><a href="itplus_8h.html#a38a907117c644761f094973916334a18">DefineIterTake</a></div><div class="ttdeci">#define DefineIterTake(T)</div><div class="ttdoc">Define an IterTake struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:1301</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Take the first 10 elements from `it` (of type `Iterable(int)`)</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) it10 = wrap_intitrtk(&amp;(<a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(<span class="keywordtype">int</span>)){ .limit = 10, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTake</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6" title="Convenience macro to get the type of the IterTake struct with given element type.">IterTake(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="ab452ed305d5190978aa0d4327e33c408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452ed305d5190978aa0d4327e33c408">&#9670;&nbsp;</a></span>define_itertakewhile_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_itertakewhile_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) ITPL_CONCAT(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T), _nxt)(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T) * <span class="keyword">self</span>)                                       \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        if (self-&gt;done) {                                                                                              \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        Iterable(T) srcit = <span class="keyword">self</span>-&gt;src;                                                                                 \</div>
<div class="line">        Maybe(T) res      = srcit.tc-&gt;next(srcit.self);                                                                \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(res) || !self-&gt;pred(<a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(res))) {                                                         \</div>
<div class="line">            self-&gt;done = <span class="keyword">true</span>;                                                                                         \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(T);                                                                                         \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return res;                                                                                                    \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T)*, T, Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T), _nxt))</div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260" title="Convenience macro to get the type of the IterTakeWhile struct with given element type.">IterTakeWhile(T)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260" title="Convenience macro to get the type of the IterTakeWhile struct with given element type.">IterTakeWhile(T)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260" title="Convenience macro to get the type of the IterTakeWhile struct with given element type.">IterTakeWhile(T)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">DefineIterTakeWhile</a>(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterTakeWhile(int)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(int) wrap_intitrtkwhl(IterTakeWhile(int)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#ab452ed305d5190978aa0d4327e33c408">define_itertakewhile_func</a>(<span class="keywordtype">int</span>, wrap_intitrtkwhl)</div>
<div class="ttc" id="aitplus_8h_html_a789b4cc6f8b2fc52ed79788fbf45d4e6"><div class="ttname"><a href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">DefineIterTakeWhile</a></div><div class="ttdeci">#define DefineIterTakeWhile(T)</div><div class="ttdoc">Define an IterTakeWhile struct that works on Iterable(T)s.</div><div class="ttdef"><b>Definition:</b> itplus.h:1388</div></div>
<div class="ttc" id="aitplus_8h_html_ab452ed305d5190978aa0d4327e33c408"><div class="ttname"><a href="itplus_8h.html#ab452ed305d5190978aa0d4327e33c408">define_itertakewhile_func</a></div><div class="ttdeci">#define define_itertakewhile_func(T, Name)</div><div class="ttdoc">Define a function to turn an IterTakeWhile(T) into an Iterable(T).</div><div class="ttdef"><b>Definition:</b> itplus.h:1434</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<ul>
<li><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> is_even(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; }</div>
</div><!-- fragment --></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Take elements from `it` (of type `Iterable(int)`), while they satisfy `is_even`, and create a new iterable</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) first_evens = wrap_intitrtkwhl(&amp;(<a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(<span class="keywordtype">int</span>)){ .pred = is_even, .src = it });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTakeWhile</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260" title="Convenience macro to get the type of the IterTakeWhile struct with given element type.">IterTakeWhile(T)</a> for the given <code>T</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a39546aa28cec10faef57954e59bd0950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39546aa28cec10faef57954e59bd0950">&#9670;&nbsp;</a></span>define_iterzip_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_iterzip_func</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U)) ITPL_CONCAT(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, U), _nxt)(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, U) * <span class="keyword">self</span>)                                    \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) asrcit = <span class="keyword">self</span>-&gt;asrc;                                                                               \</div>
<div class="line">        Iterable(U) bsrcit = <span class="keyword">self</span>-&gt;bsrc;                                                                               \</div>
<div class="line">        Maybe(T) ares      = asrcit.tc-&gt;next(asrcit.self);                                                             \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(ares)) {                                                                                        \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U));                                                                                \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        Maybe(U) bres = bsrcit.tc-&gt;next(bsrcit.self);                                                                  \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(bres)) {                                                                                        \</div>
<div class="line">            return <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U));                                                                                \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">        return <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(<a class="code" href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">PairOf</a>(<a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(ares), <a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(bres), T, U), <a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U));                                     \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">    impl_iterator(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, U)*, <a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U), Name, ITPL_CONCAT(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, U), _nxt))</div>
</div><!-- fragment -->
<p>Define a function to turn an <a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2" title="Convenience macro to get the type of the IterZip struct with given element types.">IterZip(T, U)</a> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> where <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a></code>. </p>
<p class="">Define the <code>next</code> function implementation for the <a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2" title="Convenience macro to get the type of the IterZip struct with given element types.">IterZip(T, U)</a> struct, and use it to implement the Iterator typeclass, for given <code>T</code> and <code>U</code>.</p>
<p class="">The defined function takes in a value of type <code><a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2" title="Convenience macro to get the type of the IterZip struct with given element types.">IterZip(T, U)</a>*</code> and wraps it in an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(Pair(T, U))</a></code>.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">DefineIterZip</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement `Iterator` for `IterZip(int, char)`</span></div>
<div class="line"><span class="comment">// The defined function has the signature- `Iterable(Pair(int, char)) wrap_intchrzip(IterZip(int, char)* x)`</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950">define_iterzip_func</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>, wrap_intchrzip)</div>
<div class="ttc" id="aitplus_8h_html_a39546aa28cec10faef57954e59bd0950"><div class="ttname"><a href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950">define_iterzip_func</a></div><div class="ttdeci">#define define_iterzip_func(T, U, Name)</div><div class="ttdoc">Define a function to turn an IterZip(T, U) into an Iterable(T) where T = Pair(T, U).</div><div class="ttdef"><b>Definition:</b> itplus.h:1531</div></div>
<div class="ttc" id="aitplus_8h_html_ab9ecdbe44b62bf0fee28e221e58a97f8"><div class="ttname"><a href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">DefineIterZip</a></div><div class="ttdeci">#define DefineIterZip(T, U)</div><div class="ttdoc">Define an IterZip struct that works with an Iterable(T) and an Iterable(U).</div><div class="ttdef"><b>Definition:</b> itplus.h:1488</div></div>
</div><!-- fragment --><p class="">Usage of the defined function-</p>
<div class="fragment"><div class="line"><span class="comment">// Zip together `intit` (of type `Iterable(int)`) and `chrit` (of type `Iterable(char)`)</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>)) int_chr_it = wrap_intchrzip(&amp;(<a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>)){ .asrc = intit, .bsrc = chrit });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the first <code>Iterable</code> wrapped in this <code>IterZip</code> will yield. </td></tr>
    <tr><td class="paramname">U</td><td>The type of value the second <code>Iterable</code> wrapped in this <code>IterZip</code> will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2" title="Convenience macro to get the type of the IterZip struct with given element types.">IterZip(T, U)</a> for the given <code>T</code> and <code>U</code> <b>must</b> exist. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a>, with <code>T = <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a></code>, for the given <code>T</code> and <code>U</code> must exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a938f3e7187cb386e2bf4049753e2ff84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938f3e7187cb386e2bf4049753e2ff84">&#9670;&nbsp;</a></span>DefineIteratorOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIteratorOf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <a class="code" href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(<a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) (*<span class="keyword">const</span> next)(<span class="keywordtype">void</span>* <span class="keyword">self</span>)) <a class="code" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a>(T);                                                 \</div>
<div class="line">    typedef <a class="code" href="itplus_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a>(<a class="code" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a>(T)) <a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(T)</div>
<div class="ttc" id="aitplus_8h_html_a6c3a22862dc6db425dd4389987c0dbaf"><div class="ttname"><a href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a></div><div class="ttdeci">#define Iterator(T)</div><div class="ttdoc">Convenience macro to get the type of the Iterator (typeclass) with given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:253</div></div>
<div class="ttc" id="aitplus_8h_html_ab36f9f0d3603452a867a683078618034"><div class="ttname"><a href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a></div><div class="ttdeci">#define typeclass(funcs)</div><div class="ttdoc">Define a typeclass with the given functions.</div><div class="ttdef"><b>Definition:</b> itplus.h:56</div></div>
<div class="ttc" id="aitplus_8h_html_af018200b2431a3ab6c296cc8940ecbe3"><div class="ttname"><a href="itplus_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a></div><div class="ttdeci">#define typeclass_instance(Typeclass)</div><div class="ttdoc">Define a typeclass instance for the given typeclass.</div><div class="ttdef"><b>Definition:</b> itplus.h:76</div></div>
</div><!-- fragment -->
<p>Define an Iterator typeclass and its Iterable instance for given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an Iterator(int) typeclass as well as its instance</span></div>
<div class="ttc" id="aitplus_8h_html_a938f3e7187cb386e2bf4049753e2ff84"><div class="ttname"><a href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a></div><div class="ttdeci">#define DefineIteratorOf(T)</div><div class="ttdoc">Define an Iterator typeclass and its Iterable instance for given element type.</div><div class="ttdef"><b>Definition:</b> itplus.h:287</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterator</code> instance will yield. Must be alphanumeric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
A <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a1382e263ec1cd56a19bf91d8292a2824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1382e263ec1cd56a19bf91d8292a2824">&#9670;&nbsp;</a></span>DefineIterChain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterChain</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) curr;                                                                                              \</div>
<div class="line">        Iterable(T) nxt;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterChain struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">DefineIterChain</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterChain(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterChain</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a71664a9dd47e10449841bfc1d6248503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71664a9dd47e10449841bfc1d6248503">&#9670;&nbsp;</a></span>DefineIterDrop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterDrop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        size_t i;                                                                                                      \</div>
<div class="line">        size_t limit;                                                                                                  \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterDrop struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">DefineIterDrop</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterDrop(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDrop</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="ad6129389904af6d8e22a76da42bd5961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6129389904af6d8e22a76da42bd5961">&#9670;&nbsp;</a></span>DefineIterDropWhile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterDropWhile</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        bool (*pred)(T x);                                                                                             \</div>
<div class="line">        bool done;                                                                                                     \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterDropWhile struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">DefineIterDropWhile</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterDropWhile(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDropWhile</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a01a1c0c9b689bff859e100034f192fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1c0c9b689bff859e100034f192fc1">&#9670;&nbsp;</a></span>DefineIterEnumr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterEnumr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        size_t i;                                                                                                      \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterEnumr struct that works with on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">DefineIterEnumr</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterEnumr(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterEnumr</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a044891877ea79ca3eb40ca33b511daaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044891877ea79ca3eb40ca33b511daaf">&#9670;&nbsp;</a></span>DefineIterFilt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterFilt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        bool (*pred)(T x);                                                                                             \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterFilt struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">DefineIterFilt</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterFilt(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterFilt</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="aa00013069bf4e36640355ded3b293d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00013069bf4e36640355ded3b293d72">&#9670;&nbsp;</a></span>DefineIterFiltMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterFiltMap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Maybe(FnRetType) (*f)(ElmntType x);                                                                            \</div>
<div class="line">        Iterable(ElmntType) src;                                                                                       \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(ElmntType, FnRetType)</div>
</div><!-- fragment -->
<p>Define an IterFiltMap struct that maps a function of type <code>FnRetType (*)(ElmntType)</code> over an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a></code>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">DefineIterFiltMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>); <span class="comment">// Defines an IterFiltMap(int, int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterFiltMap</code> will yield. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The <b>raw</b> type of value the function contained within an <code>IterFiltMap</code> struct will return. A <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> for given <code>FnRetType</code> must exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for given <code>ElmntType</code>, and <code>FnRetType</code> <b>must</b> also exist. </dd>
<dd>
A filter-map function returns a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>, where <code>T</code> is <code>FnRetType</code>, also referred to as the "raw" return type. </dd></dl>

</div>
</div>
<a id="af8959a5cb249799f82f0c769fd43586e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8959a5cb249799f82f0c769fd43586e">&#9670;&nbsp;</a></span>DefineIterMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterMap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        FnRetType (*f)(ElmntType x);                                                                                   \</div>
<div class="line">        Iterable(ElmntType) src;                                                                                       \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(ElmntType, FnRetType)</div>
</div><!-- fragment -->
<p>Define an IterMap struct that maps a function of type <code>FnRetType (*)(ElmntType)</code> over an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a></code>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">DefineIterMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>); <span class="comment">// Defines an IterMap(int, int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterMap</code> will yield. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The type of value the function contained within an <code>IterMap</code> struct will return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for given <code>ElmntType</code>, and <code>FnRetType</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a38a907117c644761f094973916334a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a907117c644761f094973916334a18">&#9670;&nbsp;</a></span>DefineIterTake</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterTake</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        size_t i;                                                                                                      \</div>
<div class="line">        size_t limit;                                                                                                  \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterTake struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a38a907117c644761f094973916334a18">DefineIterTake</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterTake(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTake</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a789b4cc6f8b2fc52ed79788fbf45d4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789b4cc6f8b2fc52ed79788fbf45d4e6">&#9670;&nbsp;</a></span>DefineIterTakeWhile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterTakeWhile</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        bool (*pred)(T x);                                                                                             \</div>
<div class="line">        bool done;                                                                                                     \</div>
<div class="line">        Iterable(T) src;                                                                                               \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(T)</div>
</div><!-- fragment -->
<p>Define an IterTakeWhile struct that works on <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">DefineIterTakeWhile</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines an IterTakeWhile(int) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTakeWhile</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="ab9ecdbe44b62bf0fee28e221e58a97f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ecdbe44b62bf0fee28e221e58a97f8">&#9670;&nbsp;</a></span>DefineIterZip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineIterZip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Iterable(T) asrc;                                                                                              \</div>
<div class="line">        Iterable(U) bsrc;                                                                                              \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(T, U)</div>
</div><!-- fragment -->
<p>Define an IterZip struct that works with an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code> and an <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(U)</a></code>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">DefineIterZip</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>); <span class="comment">// Defines an IterZip(int, char) struct</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the first <code>Iterable</code> wrapped in this <code>IterZip</code> will yield. </td></tr>
    <tr><td class="paramname">U</td><td>The type of value the second <code>Iterable</code> wrapped in this <code>IterZip</code> will yield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
An <a class="el" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf" title="Convenience macro to get the type of the Iterator (typeclass) with given element type.">Iterator(T)</a> for the given <code>T</code> and <code>U</code> <b>must</b> also exist. </dd></dl>

</div>
</div>
<a id="a0daf26d181160b7fb96d640ed20bb466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daf26d181160b7fb96d640ed20bb466">&#9670;&nbsp;</a></span>DefineMaybe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefineMaybe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        MaybeTag tag;                                                                                                  \</div>
<div class="line">        <span class="comment">/* Don&#39;t access this member manually */</span>                                                                        \</div>
<div class="line">        T val;                                                                                                         \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T);                                                                                                        \</div>
<div class="line">    static <span class="keyword">inline</span> T ITPL_CONCAT(T, _from_just)(<a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) maybex)                                                        \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        if (<a class="code" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(maybex)) {                                                                                         \</div>
<div class="line">            return maybex.val;                                                                                         \</div>
<div class="line">        } <span class="keywordflow">else</span> {                                                                                                       \</div>
<div class="line">            fputs(<span class="stringliteral">&quot;Attempted to extract Just value from Nothing&quot;</span>, stderr);                                             \</div>
<div class="line">            abort();                                                                                                   \</div>
<div class="line">        }                                                                                                              \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define a Maybe&lt;T&gt; type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(<span class="keywordtype">int</span>) <span class="comment">// Defines a Maybe(int) type as well as its corresponding functions</span></div>
<div class="ttc" id="aitplus_8h_html_a0daf26d181160b7fb96d640ed20bb466"><div class="ttname"><a href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a></div><div class="ttdeci">#define DefineMaybe(T)</div><div class="ttdoc">Define a Maybe&lt;T&gt; type.</div><div class="ttdef"><b>Definition:</b> itplus.h:125</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value this <code>Maybe</code> will hold. Must be alphanumeric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="af47436e1eab38cb119ab53fce7ab67e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47436e1eab38cb119ab53fce7ab67e0">&#9670;&nbsp;</a></span>DefinePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefinePair</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct                                                                                                     </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        T a;                                                                                                           \</div>
<div class="line">        U b;                                                                                                           \</div>
<div class="line">    } <a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U)</div>
</div><!-- fragment -->
<p>Define a Pair&lt;T, U&gt; type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>); <span class="comment">// Defines a Pair(int, char) type</span></div>
<div class="ttc" id="aitplus_8h_html_af47436e1eab38cb119ab53fce7ab67e0"><div class="ttname"><a href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a></div><div class="ttdeci">#define DefinePair(T, U)</div><div class="ttdoc">Define a Pair&lt;T, U&gt; type.</div><div class="ttdef"><b>Definition:</b> itplus.h:389</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type the first value in this <code>Pair</code> struct. </td></tr>
    <tr><td class="paramname">T</td><td>The type the second value in this <code>Pair</code> struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="ae7ec30413b0bc92c99b5c095578e368d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ec30413b0bc92c99b5c095578e368d">&#9670;&nbsp;</a></span>DefnIterplus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DefnIterplus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">takefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dropfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mapfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">filterfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reducefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">foldfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">filter_mapfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chainfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">takewhilefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dropwhilefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">enumeratefn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">zipfn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">collectfn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603">define_itertake_func</a>(T, takefn) <a class="code" href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad">define_iterdrop_func</a>(T, dropfn) <a class="code" href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73">define_itermap_func</a>(T, T, mapfn)                   \</div>
<div class="line">        define_iterfilt_func(T, filterfn) <a class="code" href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe">define_iterfiltmap_func</a>(T, T, filter_mapfn)                                  \</div>
<div class="line">            define_iterchain_func(T, chainfn) <a class="code" href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3">define_iterreduce_func</a>(T, reducefn)                                      \</div>
<div class="line">                define_itertakewhile_func(T, takewhilefn) <a class="code" href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24">define_iterdropwhile_func</a>(T, dropwhilefn)                    \</div>
<div class="line">                    define_itercollect_func(T, collectfn) <a class="code" href="itplus_8h.html#af8803f1b77884ca096246f7d95392e37">define_iterfold_func</a>(T, T, foldfn)                           \</div>
<div class="line">                        define_iterenumr_func(T, enumeratefn) <a class="code" href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950">define_iterzip_func</a>(T, T, zipfn)</div>
</div><!-- fragment -->
<p>Define all iterplus utilities for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> for given <code>T</code>, with given names. </p>
<p class="">The utilities defined are- <code>take</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a287ad5fb9bef31ac9370b3a231a82603" title="Define a function to turn an IterTake(T) into an Iterable(T).">define_itertake_func(T, Name)</a></p>
<p class=""><code>drop</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a82e8516570a9996f2d26ab4b959687ad" title="Define a function to turn an IterDrop(T) into an Iterable(T).">define_iterdrop_func(T, Name)</a></p>
<p class=""><code>map</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> -&gt; <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> with function type - <code>T (*)(T)</code> (<code>T -&gt; T</code>). <a class="el" href="itplus_8h.html#a4dc643234203e036aa3e0dede29beb73" title="Define a function to turn an IterMap(ElmntType, FnRetType) into an Iterable(FnRetType).">define_itermap_func</a>(ElmntType, FnRetType, Name)</p>
<p class=""><code>filter</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#aaac99e224f5b437d2d8cff83053cec2c" title="Define a function to turn an IterFilt(T) into an Iterable(T).">define_iterfilt_func(T, Name)</a></p>
<p class=""><code>reduce</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a00b36795100b8dd110f7f29c0c67e4b3" title="Define the reduce function for an iterable.">define_iterreduce_func(T, Name)</a></p>
<p class=""><code>fold</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> -&gt; <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> with function type - <code>T (*)(T, T)</code> (<code>T -&gt; T -&gt; T</code>). define_iterfold_func(T, Acc, Name)</p>
<p class=""><code>filter_map</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> -&gt; <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> with function type - <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> (*)(T)</code> (<code>T -&gt; <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a></code>). <a class="el" href="itplus_8h.html#a1c7f3e9d5e37fe8fcf894f1795ebd1fe" title="Define a function to turn an IterFiltMap(ElmntType, FnRetType) into an Iterable(FnRetType).">define_iterfiltmap_func(ElmntType, FnRetType, Name)</a></p>
<p class=""><code>chain</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>s. <a class="el" href="itplus_8h.html#a2997b1c1acb16a74ad058b5dd4efb13c" title="Define a function to turn an IterChain(T) into an Iterable(T).">define_iterchain_func(T, Name)</a></p>
<p class=""><code>takewhile</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#ab452ed305d5190978aa0d4327e33c408" title="Define a function to turn an IterTakeWhile(T) into an Iterable(T).">define_itertakewhile_func(T, Name)</a></p>
<p class=""><code>dropwhile</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a8ee7dc73bbaa1d2abde64dab352a6c24" title="Define a function to turn an IterDropWhile(T) into an Iterable(T).">define_iterdropwhile_func(T, Name)</a></p>
<p class=""><code>enumerate</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a4c033b2db8a15dda35aebfb417950443" title="Define a function to turn an IterEnumr(T) into an Iterable(T) where T = Pair(size_t,...">define_iterenumr_func(T, Name)</a></p>
<p class=""><code>zip</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>s. <a class="el" href="itplus_8h.html#a39546aa28cec10faef57954e59bd0950" title="Define a function to turn an IterZip(T, U) into an Iterable(T) where T = Pair(T, U).">define_iterzip_func(T, U, Name)</a></p>
<p class=""><code>collect</code> for <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>. <a class="el" href="itplus_8h.html#a85f93dbce7d63cb1c11818e4bf867a22" title="Define the collect function for an iterable.">define_itercollect_func(T, Name)</a></p>
<p class="">Refer to the <code>define_</code> macros for each of these utilities for usage.</p>
<p class="">You can use <a class="el" href="itplus_8h.html#a2d42bf07174d44f9e400ce68d5d7b9f6" title="Declare iterplus utility functions defined using DefnIterplus.">DeclIterplus</a>(T, takefn, dropfn, mapfn, filterfn, reducefn, foldfn, filter_mapfn, chainfn, takewhilefn, dropwhilefn, enumeratefn, zipfn, collectfn) with the same arguments to declare all the function signatures.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ae7ec30413b0bc92c99b5c095578e368d">DefnIterplus</a>(<span class="keywordtype">int</span>, inttake_itr, intdrop_itr, intintmap_itr, intfilt_itr, intreduce, intfold, intfiltmap_itr,</div>
<div class="line">intchain_itr, inttkwhl_itr, intdrpwhl_itr, intenumr_itr, intzip_itr, intclct);</div>
<div class="line"><span class="comment">// Defines functions with the following signatures:-</span></div>
<div class="line"><span class="comment">// Iterable(int) inttake_itr(IterTake(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intdrop_itr(IterDrop(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intintmap_itr(IterMap(int, int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intfilt_itr(IterFilt(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intfiltmap_itr(IterFiltMap(int, int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intchain_itr(IterChain(int) * x);</span></div>
<div class="line"><span class="comment">// Maybe(int) intreduce(Iterable(int) it, int (*f)(int acc, int x));</span></div>
<div class="line"><span class="comment">// Iterable(int) inttkwhl_itr(IterTakeWhile(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(int) intdrpwhl_itr(IterDropWhile(int) * x);</span></div>
<div class="line"><span class="comment">// int* intclct(Iterable(int) it, size_t* len);</span></div>
<div class="line"><span class="comment">// int intfold(Iterable(int) it, int init, int (*f)(int acc, int x));</span></div>
<div class="line"><span class="comment">// Iterable(Pair(size_t, int)) intenumr_itr(IterEnumr(int) * x);</span></div>
<div class="line"><span class="comment">// Iterable(Pair(int, int)) intzip_itr(IterZip(int, int) * x);</span></div>
<div class="ttc" id="aitplus_8h_html_ae7ec30413b0bc92c99b5c095578e368d"><div class="ttname"><a href="itplus_8h.html#ae7ec30413b0bc92c99b5c095578e368d">DefnIterplus</a></div><div class="ttdeci">#define DefnIterplus(T, takefn, dropfn, mapfn, filterfn, reducefn, foldfn, filter_mapfn, chainfn, takewhilefn, dropwhilefn, enumeratefn, zipfn, collectfn)</div><div class="ttdoc">Define all iterplus utilities for Iterable(T) for given T, with given names.</div><div class="ttdef"><b>Definition:</b> itplus.h:1719</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The element type of the <code>Iterator</code> and iterplus utilities being defined. </td></tr>
    <tr><td class="paramname">takefn</td><td>Name to define the <code>take</code> impl as. </td></tr>
    <tr><td class="paramname">dropfn</td><td>Name to define the <code>drop</code> impl as. </td></tr>
    <tr><td class="paramname">mapfn</td><td>Name to define the <code>map</code> (<a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a> -&gt; <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a>) impl as. </td></tr>
    <tr><td class="paramname">filterfn</td><td>Name to define the <code>filter</code> impl as. </td></tr>
    <tr><td class="paramname">reducefn</td><td>Name to define the <code>reduce</code> impl as. </td></tr>
    <tr><td class="paramname">foldfn</td><td>Name to define the <code>fold</code> (Accumulator type <code>T</code>) impl as. </td></tr>
    <tr><td class="paramname">filter_mapfn</td><td>Name to define the <code>filter_map</code> impl as. </td></tr>
    <tr><td class="paramname">chainfn</td><td>Name to define the <code>chain</code> impl as. </td></tr>
    <tr><td class="paramname">takewhilefn</td><td>Name to define the <code>takewhile</code> impl as. </td></tr>
    <tr><td class="paramname">dropwhilefn</td><td>Name to define the <code>dropwhile</code> impl as. </td></tr>
    <tr><td class="paramname">enumeratefn</td><td>Name to define the <code>enumerate</code> impl as. </td></tr>
    <tr><td class="paramname">zipfn</td><td>Name to define the <code>zip</code> (To zip 2 <code><a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(T)</a></code>s) impl as. </td></tr>
    <tr><td class="paramname">collectfn</td><td>Name to define the <code>collect</code> impl as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a78cf196d6558cc31ef4f88e5cf47bdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cf196d6558cc31ef4f88e5cf47bdf9">&#9670;&nbsp;</a></span>fmap_maybe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fmap_maybe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">R&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="itplus_8h.html#a1b03ece9f7b00fcbbe8e0dde45277c47">is_nothing</a>(x) ? <a class="el" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(R) : <a class="el" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(fn(<a class="el" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(x)), R)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the function <code>fn</code> over <code>x</code> to construct a <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(R)</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>Maybe</code> type to map over. </td></tr>
    <tr><td class="paramname">fn</td><td>The function to map over the value inside the <code>Maybe</code> (if any). Should be of type <code>R (*)(T x)</code>. Where <code>T</code> is the type of value contained within <code>x</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the mapping function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>x</code> had a value, a <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(B)</a></code> with a <code>Just</code> value after mapping <code>fn</code>. Otherwise, a <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(B)</a></code> as <code>Nothing</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This uses <code>x</code> twice. Do not use it with an <code>x</code> that may have side effects. </dd></dl>

</div>
</div>
<a id="a80a0308d3d97154ab14aa4025fcbacd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a0308d3d97154ab14aa4025fcbacd0">&#9670;&nbsp;</a></span>foreach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define foreach</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">it&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T) UNIQVAR(res) = (it).tc-&gt;next((it).self);                                                                  \</div>
<div class="line">    for (T x          = <a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(UNIQVAR(res)); <a class="code" href="itplus_8h.html#a8ae2e9c065fbca1cd3a603ad0a71d8f2">is_just</a>(UNIQVAR(res));                                               \</div>
<div class="line">         UNIQVAR(res) = (it).tc-&gt;next((it).self), x = <a class="code" href="itplus_8h.html#a16682b211c71e2ad917edc9bdd298154">from_just_</a>(UNIQVAR(res)))</div>
</div><!-- fragment -->
<p>Iterate through given iterable and store each element in <code>x</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Type of the elements the iterable yields. </td></tr>
    <tr><td class="paramname">x</td><td>The variable name to store each element in. Available only inside the loop. </td></tr>
    <tr><td class="paramname">it</td><td>The iterable to iterate over. This will be consumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>it</code> must not be an unevaluated expression. Otherwise, it will be evaluated multiple times in this macro. </dd>
<dd>
This macro cannot be used multiple times <em>in the same line</em>. Due to naming conflicts from an implicitly defined variable. </dd></dl>

</div>
</div>
<a id="a26feaafcb3e37674333f6673ec2bdb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26feaafcb3e37674333f6673ec2bdb7d">&#9670;&nbsp;</a></span>from_just</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define from_just</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ITPL_CONCAT(T, _from_just(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the <code>Just</code> value from given <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>Maybe</code> type to extract the value from. </td></tr>
    <tr><td class="paramname">T</td><td>The type of value the <code>Maybe</code> will hold. Must be alphanumeric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Just</code> value of type corresponding to the given <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> if it's not <code>Nothing</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
Aborts the program if given <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> struct was tagged with <code>Nothing</code>. </dd></dl>

</div>
</div>
<a id="a16682b211c71e2ad917edc9bdd298154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16682b211c71e2ad917edc9bdd298154">&#9670;&nbsp;</a></span>from_just_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define from_just_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x).val</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Unsafe" version of <a class="el" href="itplus_8h.html#a26feaafcb3e37674333f6673ec2bdb7d" title="Extract the Just value from given Maybe(T).">from_just(x, T)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>Maybe</code> type to extract the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Just</code> value of type corresponding to the given <code>Maybe</code> struct.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not check whether the <code>Maybe</code> struct actually has a value and hence should only be used when the caller is sure that the Maybe contains a <code>Just</code> value. Otherwise the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a01e620430099d2eb6192db193e88cff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e620430099d2eb6192db193e88cff0">&#9670;&nbsp;</a></span>impl_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define impl_iterator</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">IterType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next_f&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(ElmntType) Name(IterType x)                                                                               \</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        Maybe(ElmntType) (*<span class="keyword">const</span> next_)(IterType <span class="keyword">self</span>) = (next_f);                                                     \</div>
<div class="line">        (void)next_;                                                                                                   \</div>
<div class="line">        static <a class="code" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a>(ElmntType) <span class="keyword">const</span> tc = {.next = (<a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(ElmntType)(*const)(<span class="keywordtype">void</span>*))(next_f)};                     \</div>
<div class="line">        return (<a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(ElmntType)){.tc = &amp;tc, .self = x};                                                            \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define a function to turn given <code>IterType</code> into an <a class="el" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a" title="Convenience macro to get the type of the Iterable (typeclass instance) with given element type.">Iterable(ElmntType)</a>. </p>
<p class="">Implement the Iterator typeclass for a type. Essentially defining a wrapper function that returns the Iterable.</p>
<p class="">The defined function takes in a value of <code>IterType</code> and wraps it in an <code>Iterable</code> - which can be passed around to generic functions working on an iterable.</p>
<p class="">The term "generic" is used here in the context of the <b>input</b>. As in, the function taking a generic iterable, does not care about what type is backing up the iterable; but, does care about what element type the iterator yields.</p>
<h1>Example</h1>
<div class="fragment"><div class="line"><span class="comment">// Example of implementing an infinite iterator representing the fibonacci sequence</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>fibonacci</div>
<div class="line">{</div>
<div class="line">    uint32_t curr;</div>
<div class="line">    uint32_t next;</div>
<div class="line">} Fibonacci;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(uint32_t)</div>
<div class="line"><a class="code" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(uint32_t);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(uint32_t) fibnxt(Fibonacci* <span class="keyword">self</span>)</div>
<div class="line">{</div>
<div class="line">    uint32_t new_nxt = <span class="keyword">self</span>-&gt;curr + <span class="keyword">self</span>-&gt;next;</div>
<div class="line">    <span class="keyword">self</span>-&gt;curr       = <span class="keyword">self</span>-&gt;next;</div>
<div class="line">    <span class="keyword">self</span>-&gt;next       = new_nxt;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(new_nxt, uint32_t);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a function named `prep_fib_itr`, which takes in a `Fibonacci*` and returns an `Iterable(int)`</span></div>
<div class="line"><span class="comment">// The returned iterable is an infinite fibonacci sequence</span></div>
<div class="line"><a class="code" href="itplus_8h.html#a01e620430099d2eb6192db193e88cff0">impl_iterator</a>(Fibonacci*, uint32_t, prep_fib_itr, fibnxt)</div>
<div class="ttc" id="aitplus_8h_html_a01e620430099d2eb6192db193e88cff0"><div class="ttname"><a href="itplus_8h.html#a01e620430099d2eb6192db193e88cff0">impl_iterator</a></div><div class="ttdeci">#define impl_iterator(IterType, ElmntType, Name, next_f)</div><div class="ttdoc">Define a function to turn given IterType into an Iterable(ElmntType).</div><div class="ttdef"><b>Definition:</b> itplus.h:345</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IterType</td><td>The semantic type (C type) this impl is for, must be a pointer type. </td></tr>
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterator</code> instance will yield. </td></tr>
    <tr><td class="paramname">Name</td><td>Name to define the function as. </td></tr>
    <tr><td class="paramname">next_f</td><td>Function pointer that serves as the <code>next</code> implementation for <code>IterType</code>. This function must have the signature of <code><a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(ElmntType)</a> (*)(IterType self)</code> - i.e, should take IterType and return a value of the corresponding element type wrapped in a <code>Maybe</code> - <code>Nothing</code> value indicates end of iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
A <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> for the given <code>ElmntType</code> <b>must</b> exist. </dd>
<dd>
This should not be delimited by a semicolon. </dd></dl>

</div>
</div>
<a id="a8ae2e9c065fbca1cd3a603ad0a71d8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae2e9c065fbca1cd3a603ad0a71d8f2">&#9670;&nbsp;</a></span>is_just</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_just</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x).tag == <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2">MaybeTag_Just</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given Maybe type is tagged with <code>Just</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> struct to check against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b03ece9f7b00fcbbe8e0dde45277c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b03ece9f7b00fcbbe8e0dde45277c47">&#9670;&nbsp;</a></span>is_nothing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_nothing</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x).tag == <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230aae774bc4d692f226f6a9d88b7e1ce26f">MaybeTag_Nothing</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given Maybe type is tagged with <code>Nothing</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> struct to check against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78f1cf949c0e970b2105124f691f5c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f1cf949c0e970b2105124f691f5c2a">&#9670;&nbsp;</a></span>Iterable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Iterable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(Iterable_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the Iterable (typeclass instance) with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type Iterable(Int) (the typeclass instance)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84" title="Define an Iterator typeclass and its Iterable instance for given element type.">DefineIteratorOf(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a6c3a22862dc6db425dd4389987c0dbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3a22862dc6db425dd4389987c0dbaf">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Iterator</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(Iterator_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the Iterator (typeclass) with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a6c3a22862dc6db425dd4389987c0dbaf">Iterator</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type Iterator(int) (a typeclass)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterator</code> instance will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84" title="Define an Iterator typeclass and its Iterable instance for given element type.">DefineIteratorOf(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a57f7569f7996a4aa3ae1aa3d0327ec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f7569f7996a4aa3ae1aa3d0327ec75">&#9670;&nbsp;</a></span>IterChain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterChain</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterChain_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterChain struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824">DefineIterChain</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a57f7569f7996a4aa3ae1aa3d0327ec75">IterChain</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterChain(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterChain</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a1382e263ec1cd56a19bf91d8292a2824" title="Define an IterChain struct that works on Iterable(T)s.">DefineIterChain(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a6e55b9588c1634ec791b400eb4a9011e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e55b9588c1634ec791b400eb4a9011e">&#9670;&nbsp;</a></span>IterDrop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterDrop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterDrop_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterDrop struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503">DefineIterDrop</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a6e55b9588c1634ec791b400eb4a9011e">IterDrop</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterDrop(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDrop</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a71664a9dd47e10449841bfc1d6248503" title="Define an IterDrop struct that works on Iterable(T)s.">DefineIterDrop(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a883f6455eceac6d293e6e54414c3356e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f6455eceac6d293e6e54414c3356e">&#9670;&nbsp;</a></span>IterDropWhile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterDropWhile</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterDropWhile_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterDropWhile struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961">DefineIterDropWhile</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a883f6455eceac6d293e6e54414c3356e">IterDropWhile</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterDropWhile(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterDropWhile</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#ad6129389904af6d8e22a76da42bd5961" title="Define an IterDropWhile struct that works on Iterable(T)s.">DefineIterDropWhile(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="ae3969ffb53f197e7b65f90dce652cb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3969ffb53f197e7b65f90dce652cb5b">&#9670;&nbsp;</a></span>IterEnumr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterEnumr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterEnumr_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterEnumr struct with given element types. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1">DefineIterEnumr</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#ae3969ffb53f197e7b65f90dce652cb5b">IterEnumr</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterEnumr(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterEnumr</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a01a1c0c9b689bff859e100034f192fc1" title="Define an IterEnumr struct that works with on Iterable(T)s.">DefineIterEnumr(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a6a69fe586c6d8864d840c0658db0d363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69fe586c6d8864d840c0658db0d363">&#9670;&nbsp;</a></span>IterFilt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterFilt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterFilt_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterFilt struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf">DefineIterFilt</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a6a69fe586c6d8864d840c0658db0d363">IterFilt</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterFilt(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterFilt</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a044891877ea79ca3eb40ca33b511daaf" title="Define an IterFilt struct that works on Iterable(T)s.">DefineIterFilt(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a341ce8c4f7f92df65e6fdfde9e1ac575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341ce8c4f7f92df65e6fdfde9e1ac575">&#9670;&nbsp;</a></span>IterFiltMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterFiltMap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterFiltMap_, ElmntType), ITPL_CONCAT(_, FnRetType))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterFiltMap struct with given element type and function raw return type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72">DefineIterFiltMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a341ce8c4f7f92df65e6fdfde9e1ac575">IterFiltMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterFiltMap(int, int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTake</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72" title="Define an IterFiltMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(E...">DefineIterFiltMap(ElmntType, FnRetType)</a>. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The type of value the function contained within an <code>IterFiltMap</code> struct will return. Must be the same type name passed to <a class="el" href="itplus_8h.html#aa00013069bf4e36640355ded3b293d72" title="Define an IterFiltMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(E...">DefineIterFiltMap(ElmntType, FnRetType)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a2ed8fd79978d16823dc7cd3ef43fce28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8fd79978d16823dc7cd3ef43fce28">&#9670;&nbsp;</a></span>IterMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterMap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ElmntType, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FnRetType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterMap_, ElmntType), ITPL_CONCAT(_, FnRetType))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterMap struct with given element type and function return type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e">DefineIterMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a2ed8fd79978d16823dc7cd3ef43fce28">IterMap</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterMap(int, int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElmntType</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTake</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e" title="Define an IterMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(Elmnt...">DefineIterMap(ElmntType, FnRetType)</a>. </td></tr>
    <tr><td class="paramname">FnRetType</td><td>The type of value the function contained within an <code>IterMap</code> struct will return. Must be the same type name passed to <a class="el" href="itplus_8h.html#af8959a5cb249799f82f0c769fd43586e" title="Define an IterMap struct that maps a function of type FnRetType (*)(ElmntType) over an Iterable(Elmnt...">DefineIterMap(ElmntType, FnRetType)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>ElmntType</code> (or <code>FnRetType</code>) is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a5c50e13ec0251aa058caede675387b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c50e13ec0251aa058caede675387b12">&#9670;&nbsp;</a></span>Iterplus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Iterplus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(T) <a class="code" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a>(<span class="keywordtype">size_t</span>, T);                                                                              \</div>
<div class="line">    DefinePair(T, T);                                                                                                  \</div>
<div class="line">    DefineMaybe(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T)) <a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, T)) <a class="code" href="itplus_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(T);                                          \</div>
<div class="line">    DefineIteratorOf(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">size_t</span>, T));                                                                                 \</div>
<div class="line">    DefineIteratorOf(<a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, T));                                                                                      \</div>
<div class="line">    DefineIterTake(T);                                                                                                 \</div>
<div class="line">    DefineIterDrop(T);                                                                                                 \</div>
<div class="line">    DefineIterMap(T, T);                                                                                               \</div>
<div class="line">    DefineIterFilt(T);                                                                                                 \</div>
<div class="line">    DefineIterFiltMap(T, T);                                                                                           \</div>
<div class="line">    DefineIterChain(T);                                                                                                \</div>
<div class="line">    DefineIterTakeWhile(T);                                                                                            \</div>
<div class="line">    DefineIterDropWhile(T);                                                                                            \</div>
<div class="line">    DefineIterEnumr(T);                                                                                                \</div>
<div class="line">    DefineIterZip(T, T)</div>
</div><!-- fragment -->
<p>Define all structs needed for implementing <code>Iterator</code>, as well as iterplus utilities, for given <code>T</code>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a5c50e13ec0251aa058caede675387b12">Iterplus</a>(<span class="keywordtype">int</span>); <span class="comment">// Defines the following:-</span></div>
<div class="line"><span class="comment">// Maybe(T)</span></div>
<div class="line"><span class="comment">// Pair(size_t, T)</span></div>
<div class="line"><span class="comment">// Pair(T, T)</span></div>
<div class="line"><span class="comment">// Maybe(Pair(size_t, T))</span></div>
<div class="line"><span class="comment">// Maybe(Pair(T, T))</span></div>
<div class="line"><span class="comment">// Iterator(T)</span></div>
<div class="line"><span class="comment">// Iterator(Pair(size_t, T))</span></div>
<div class="line"><span class="comment">// Iterator(Pair(T, T))</span></div>
<div class="line"><span class="comment">// IterTake(T)</span></div>
<div class="line"><span class="comment">// IterDrop(T)</span></div>
<div class="line"><span class="comment">// IterMap(T, T)</span></div>
<div class="line"><span class="comment">// IterFilt(T)</span></div>
<div class="line"><span class="comment">// IterFiltMap(T, T)</span></div>
<div class="line"><span class="comment">// IterChain(T)</span></div>
<div class="line"><span class="comment">// IterTakeWhile(T)</span></div>
<div class="line"><span class="comment">// IterDropWhile(T)</span></div>
<div class="line"><span class="comment">// IterEnumr(T)</span></div>
<div class="line"><span class="comment">// IterZip(T, T)</span></div>
<div class="ttc" id="aitplus_8h_html_a5c50e13ec0251aa058caede675387b12"><div class="ttname"><a href="itplus_8h.html#a5c50e13ec0251aa058caede675387b12">Iterplus</a></div><div class="ttdeci">#define Iterplus(T)</div><div class="ttdoc">Define all structs needed for implementing Iterator, as well as iterplus utilities,...</div><div class="ttdef"><b>Definition:</b> itplus.h:1579</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The element type of the <code>Iterator</code> and iterplus utilities being defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad62bc1c52430417ab0ce36039c0c57a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62bc1c52430417ab0ce36039c0c57a6">&#9670;&nbsp;</a></span>IterTake</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterTake</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterTake, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterTake struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a38a907117c644761f094973916334a18">DefineIterTake</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#ad62bc1c52430417ab0ce36039c0c57a6">IterTake</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterTake(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTake</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a38a907117c644761f094973916334a18" title="Define an IterTake struct that works on Iterable(T)s.">DefineIterTake(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a0603baeec63df613f04d5f13f7975260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0603baeec63df613f04d5f13f7975260">&#9670;&nbsp;</a></span>IterTakeWhile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterTakeWhile</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(IterTakeWhile_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterTakeWhile struct with given element type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6">DefineIterTakeWhile</a>(<span class="keywordtype">int</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a0603baeec63df613f04d5f13f7975260">IterTakeWhile</a>(<span class="keywordtype">int</span>) i; <span class="comment">// Declares a variable of type IterTakeWhile(int)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Iterable</code> wrapped in this <code>IterTakeWhile</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#a789b4cc6f8b2fc52ed79788fbf45d4e6" title="Define an IterTakeWhile struct that works on Iterable(T)s.">DefineIterTakeWhile(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="aed4cf3e9b41350a8dbe6cb5a24d4d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">&#9670;&nbsp;</a></span>IterZip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IterZip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(IterZip_, T), ITPL_CONCAT(_, U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the IterZip struct with given element types. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8">DefineIterZip</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#aed4cf3e9b41350a8dbe6cb5a24d4d0d2">IterZip</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>) i; <span class="comment">// Declares a variable of type IterZip(int, char)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the first <code>Iterable</code> wrapped in this <code>IterZip</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8" title="Define an IterZip struct that works with an Iterable(T) and an Iterable(U).">DefineIterZip(T, U)</a>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of value the second <code>Iterable</code> wrapped in this <code>IterZip</code> will yield. Must be the same type name passed to <a class="el" href="itplus_8h.html#ab9ecdbe44b62bf0fee28e221e58a97f8" title="Define an IterZip struct that works with an Iterable(T) and an Iterable(U).">DefineIterZip(T, U)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="ae0832f95d5a7ff6845381aa8795fd2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0832f95d5a7ff6845381aa8795fd2a3">&#9670;&nbsp;</a></span>Just</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Just</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T)){.tag = <a class="el" href="itplus_8h.html#aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2">MaybeTag_Just</a>, .val = (v)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a <code>Just</code> value into a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(<span class="keywordtype">int</span>)</div>
<div class="line"><a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<span class="keywordtype">int</span>) <span class="keyword">const</span> x = <a class="code" href="itplus_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(42, <span class="keywordtype">int</span>); <span class="comment">// Initializes a Maybe(int) with the value 42</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The concrete value to wrap in <code>Just</code> (must be of the correct type). </td></tr>
    <tr><td class="paramname">T</td><td>The type of value the <code>Maybe</code> will hold. Must be alphanumeric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
The value is simply assigned to the <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a> struct. No implicit cloning is done. </dd></dl>

</div>
</div>
<a id="af47a0e4269e370939835ecc0cf6c7875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47a0e4269e370939835ecc0cf6c7875">&#9670;&nbsp;</a></span>Maybe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Maybe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;ITPL_CONCAT(Maybe_, T)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the Maybe defined with a certain type. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(<span class="keywordtype">int</span>)</div>
<div class="line"><a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<span class="keywordtype">int</span>) <span class="keyword">const</span> x = {0}; <span class="comment">// Uses the maybe type defined in the previous line</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Maybe</code> struct will contain. Must be the same type name passed to <a class="el" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466" title="Define a Maybe&lt;T&gt; type.">DefineMaybe(T)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a65cd69857cc806545d68c79464270a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cd69857cc806545d68c79464270a97">&#9670;&nbsp;</a></span>Nothing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Nothing</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(T)){0})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a <code>Nothing</code> value into a <a class="el" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875" title="Convenience macro to get the type of the Maybe defined with a certain type.">Maybe(T)</a>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(<span class="keywordtype">int</span>)</div>
<div class="line"><a class="code" href="itplus_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(<span class="keywordtype">int</span>) <span class="keyword">const</span> x = <a class="code" href="itplus_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(<span class="keywordtype">int</span>); <span class="comment">// Initializes a Maybe(int) with no value</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of value the <code>Maybe</code> will hold. Must be alphanumeric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code> is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="a4760cf36bdc0a23827c20b1963186503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4760cf36bdc0a23827c20b1963186503">&#9670;&nbsp;</a></span>Pair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pair</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ITPL_CONCAT(ITPL_CONCAT(Pair_, T), ITPL_CONCAT(_, U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to get the type of the Pair defined with certain types. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>) <span class="keyword">const</span> x = {0}; <span class="comment">// Uses the pair type defined in the previous line</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type the first value in this <code>Pair</code> struct. Must be the same type name passed to <a class="el" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0" title="Define a Pair&lt;T, U&gt; type.">DefinePair(T, U)</a> </td></tr>
    <tr><td class="paramname">T</td><td>The type the second value in this <code>Pair</code> struct. Must be the same type name passed to <a class="el" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0" title="Define a Pair&lt;T, U&gt; type.">DefinePair(T, U)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd></dl>

</div>
</div>
<a id="ac6399a724fdf5a1af19dea3e3c25ec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6399a724fdf5a1af19dea3e3c25ec21">&#9670;&nbsp;</a></span>PairOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PairOf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">U&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(T, U)){.a = (x), .b = (y)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap 2 values into a <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a>. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><a class="code" href="itplus_8h.html#af47436e1eab38cb119ab53fce7ab67e0">DefinePair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>);</div>
<div class="line"><a class="code" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503">Pair</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>) <span class="keyword">const</span> x = <a class="code" href="itplus_8h.html#ac6399a724fdf5a1af19dea3e3c25ec21">PairOf</a>(42, <span class="charliteral">&#39;c&#39;</span>, <span class="keywordtype">int</span>, <span class="keywordtype">char</span>); <span class="comment">// Initializes a Pair(int, char) with the value 42 and &#39;c&#39;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to put as the first member of the pair struct. </td></tr>
    <tr><td class="paramname">y</td><td>The value to put as the second member of the pair struct. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the first value. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the second value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>T</code>, or <code>U</code>, is a pointer, it needs to be typedef-ed into a type that does not contain the <code>*</code>. Only alphanumerics. </dd>
<dd>
A <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a> for given <code>T</code> and <code>U</code> must exist. </dd>
<dd>
The values are simply assigned to the <a class="el" href="itplus_8h.html#a4760cf36bdc0a23827c20b1963186503" title="Convenience macro to get the type of the Pair defined with certain types.">Pair(T, U)</a> struct. No implicit cloning is done. </dd></dl>

</div>
</div>
<a id="ab36f9f0d3603452a867a683078618034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36f9f0d3603452a867a683078618034">&#9670;&nbsp;</a></span>typeclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define typeclass</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">funcs</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct                                                                                                             </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        funcs;                                                                                                         \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define a typeclass with the given functions. </p>
<h1>Example</h1>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(<span class="keywordtype">char</span>* (*show)(<span class="keywordtype">void</span>* <span class="keyword">self</span>)) Show;  <span class="comment">// Defines a typeclass and names it `Show`</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">funcs</td><td>A semicolon separated list of typeclass functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The functions usually take the <code>self</code> from the typeclass instance (and possibly more arguments). </dd></dl>

</div>
</div>
<a id="af018200b2431a3ab6c296cc8940ecbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af018200b2431a3ab6c296cc8940ecbe3">&#9670;&nbsp;</a></span>typeclass_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define typeclass_instance</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Typeclass</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct                                                                                                             </span>\</div>
<div class="line">    {                                                                                                                  \</div>
<div class="line">        void* <span class="keyword">self</span>;                                                                                                    \</div>
<div class="line">        Typeclass <span class="keyword">const</span>* tc;                                                                                           \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Define a typeclass instance for the given typeclass. </p>
<p class="">This just contains a <code>void* self</code> member and the typeclass itself. </p><h1>Example</h1>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="itplus_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(<span class="keywordtype">char</span>* (*show)(<span class="keywordtype">void</span>* <span class="keyword">self</span>)) Show;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="itplus_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a>(Show) Showable; <span class="comment">// Defines the typeclass instance for `Show` typeclass</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Typeclass</td><td>The semantic type (C type) of the typeclass defined with <a class="el" href="itplus_8h.html#ab36f9f0d3603452a867a683078618034" title="Define a typeclass with the given functions.">typeclass(funcs)</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aef352f4183ce21f9ac15edd86a75b230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef352f4183ce21f9ac15edd86a75b230">&#9670;&nbsp;</a></span>MaybeTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structMaybeTag.html">MaybeTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef352f4183ce21f9ac15edd86a75b230aae774bc4d692f226f6a9d88b7e1ce26f"></a>MaybeTag_Nothing&#160;</td><td class="fielddoc"><p class=""><code>Nothing</code> tag - indicates absence of a value. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef352f4183ce21f9ac15edd86a75b230a1e57a50afd710304d82f6269f40e18c2"></a>MaybeTag_Just&#160;</td><td class="fielddoc"><p class=""><code>Just</code> tag - indicates presence of a value. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="itplus_8h.html">itplus.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>


</body>
</html>
